<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileReaderAndWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry-io</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry.io</a> &gt; <span class="el_source">FileReaderAndWriter.java</span></div><h1>FileReaderAndWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry.io;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;

/**
 * This class provides methods to access file data at random positions.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class FileReaderAndWriter extends AbstractFileReaderAndWriter {

    /**
     * Underlying input file.
     */
    private final RandomAccessFile randomAccessFile;

    /**
     * Constructor.
     *
     * @param f    file to read from or write to.
     * @param mode file opening mode (read only or read write).
     * @throws IOException if an I/O error occurs.
     */
<span class="fc" id="L41">    public FileReaderAndWriter(final File f, final FileChannel.MapMode mode) throws IOException {</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">        if (mode == FileChannel.MapMode.READ_ONLY) {</span>
<span class="fc" id="L43">            this.randomAccessFile = new RandomAccessFile(f, &quot;r&quot;);</span>
        } else {
<span class="fc" id="L45">            this.randomAccessFile = new RandomAccessFile(f, &quot;rw&quot;);</span>
        }
<span class="fc" id="L47">    }</span>

    /**
     * Reads one byte at current file position and advances one position.
     *
     * @return Next byte of data or -1 if end of file is reached.
     * @throws IOException if an I/O error occurs. Not thrown if end-of-file has
     *                     been reached.
     */
    @Override
    public int read() throws IOException {
<span class="fc" id="L58">        return randomAccessFile.read();</span>
    }

    /**
     * Reads up to b.length bytes of data from this file into an array of bytes.
     * This method blocks until at least one byte of input is available.
     *
     * @param b The buffer into which the data is read.
     * @return The total number of bytes read into the buffer, or -1 if there is
     * no more data because the end of the file has been reached.
     * @throws IOException If the first byte cannot be read for any reason other
     *                     than end of file, or if the file has been closed, or if some other I/O
     *                     error occurs.
     */
    @Override
    public int read(final byte[] b) throws IOException {
<span class="fc" id="L74">        return randomAccessFile.read(b);</span>
    }

    /**
     * Reads up to len bytes of data from this file into an array of bytes. This
     * method blocks until at least one byte of input is available.
     * This method behaves in exactly the same way as the
     * InputStream.read(byte[], int, int) method of InputStream.
     *
     * @param b   the buffer into which the data is read.
     * @param off the start offset in array b at which the data is written.
     * @param len the maximum number of bytes read.
     * @return the total number of bytes read into the buffer, or -1 if there is
     * no more data because the end of the file has been reached.
     * @throws IOException If the first byte cannot be read for any reason other
     *                     than end of file, or if the random access file has been closed, or if
     *                     some other I/O error occurs.
     */
    @Override
    public int read(final byte[] b, final int off, final int len) throws IOException {
<span class="fc" id="L94">        return randomAccessFile.read(b, off, len);</span>
    }

    /**
     * Reads b.length bytes from this file into the byte array, starting at the
     * current file pointer. This method reads repeatedly from the file until
     * the requested number of bytes are read. This method blocks until the
     * requested number of bytes are read, the end of the stream is detected, or
     * an exception is thrown.
     *
     * @param b the buffer into which the data is read.
     * @throws IOException if this file reaches the end before reading all the
     *                     bytes.
     */
    public void readFully(final byte[] b) throws IOException {
<span class="fc" id="L109">        randomAccessFile.readFully(b);</span>
<span class="fc" id="L110">    }</span>

    /**
     * Reads exactly len bytes from this file into the byte array, starting at
     * the current file pointer. This method reads repeatedly from the file
     * until the requested number of bytes are read. This method blocks until
     * the requested number of bytes are read, the end of the stream is
     * detected, or an exception is thrown.
     *
     * @param b   the buffer into which the data is read.
     * @param off the start offset of the data.
     * @param len the number of byte to read.
     * @throws IOException if this file reaches the end before reading all the
     *                     bytes or if an I/O error occurs.
     */
    public void readFully(final byte[] b, final int off, final int len) throws IOException {
<span class="fc" id="L126">        randomAccessFile.readFully(b, off, len);</span>
<span class="fc" id="L127">    }</span>

    /**
     * Attempts to skip over n byte of input discarding the skipped bytes.
     * &lt;p&gt;
     * This method may skip over some number of bytes, possibly zero. This may
     * result from any of a number of conditions; reaching end of file before n
     * bytes have been skipped is only one possibility. The actual number of
     * bytes skipped is returned. If n is negative, no bytes are skipped.
     *
     * @param n the number of bytes to be skipped.
     * @return the actual number of bytes skipped.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public long skip(final long n) throws IOException {
<span class="fc" id="L143">        return randomAccessFile.skipBytes((int) n);</span>
    }

    /**
     * Writes the specified byte to this file. The write starts at the current
     * file pointer.
     *
     * @param b the byte to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void write(final int b) throws IOException {
<span class="fc" id="L155">        randomAccessFile.write(b);</span>
<span class="fc" id="L156">    }</span>

    /**
     * Writes b.length bytes from the specified byte array to this file,
     * starting at the current file pointer.
     *
     * @param b the data.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void write(final byte[] b) throws IOException {
<span class="fc" id="L167">        randomAccessFile.write(b);</span>
<span class="fc" id="L168">    }</span>

    /**
     * Writes len bytes from the specified byte array starting at offset off to
     * this file.
     *
     * @param b   the data.
     * @param off the start offset in the data.
     * @param len the number of bytes to write.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void write(final byte[] b, final int off, final int len) throws IOException {
<span class="fc" id="L181">        randomAccessFile.write(b, off, len);</span>
<span class="fc" id="L182">    }</span>

    /**
     * Returns the current offset in this file.
     *
     * @return the offset from the beginning of the file, in bytes, at which the
     * next read or write occurs.
     * @throws IOException in an I/O error occurs.
     */
    @Override
    public long getPosition() throws IOException {
<span class="fc" id="L193">        return randomAccessFile.getFilePointer();</span>
    }

    /**
     * Determines whether end of file has been reached (next read() will return
     * -1). or not.
     *
     * @return True if end of file has been reached, false otherwise.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public boolean isEndOfStream() throws IOException {
<span class="fc bfc" id="L205" title="All 2 branches covered.">        return getPosition() &gt;= randomAccessFile.length();</span>
    }

    /**
     * Sets the file-pointer offset, measured from the beginning of this file,
     * at which the next read or write occurs. The offset may be set beyond the
     * end of the file. Setting the offset beyond the end of the file does not
     * change the file length.
     * The file length will change only by writing after the offset has been set
     * beyond the end of the file.
     *
     * @param pos the offset position, measured in bytes from the beginning of
     *            the file, at which to set the file pointer.
     * @throws IOException if pos is less than 0 or if an I/O error occurs.
     */
    @Override
    public void seek(final long pos) throws IOException {
<span class="fc" id="L222">        randomAccessFile.seek(pos);</span>
<span class="fc" id="L223">    }</span>

    /**
     * Closes this file stream and releases any system resources associated with
     * the stream. A closed file cannot perform input or output operations and
     * cannot be reopened.
     * If this file has an associated channel then the channel is closed as
     * well.
     *
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void close() throws IOException {
<span class="fc" id="L236">        randomAccessFile.close();</span>
<span class="fc" id="L237">    }</span>

    /**
     * Reads a boolean from this file. This method reads a single byte from the
     * file, starting at the current file pointer. A value of 0 represents
     * false. Any other value represents true. This method blocks until the byte
     * is read, the end of the stream is detected, or an exception is thrown.
     *
     * @return the boolean value read.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public boolean readBoolean() throws IOException {
<span class="fc" id="L250">        return randomAccessFile.readBoolean();</span>
    }

    /**
     * Reads a signed eight-bit value from this file. This method reads a byte
     * from the file, starting from the current file pointer. If the byte read
     * is b, where 0 &amp;lt;= b &amp;lt;= 255, then the result is: (byte)(b)
     * This method blocks until the byte is read, the end of the stream is
     * detected, or an exception is thrown.
     *
     * @return the next byte of this file is a signed eight-bit byte.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public byte readByte() throws IOException {
<span class="fc" id="L265">        return randomAccessFile.readByte();</span>
    }

    /**
     * Reads an unsigned eight-bit number from this file. This method reads a
     * byte from this file, starting at the current file pointer, and returns
     * that byte.
     * This method blocks until the byte is read, the end of the stream is
     * detected, or an exception is thrown.
     *
     * @return the next byte of this file, interpreted as an unsigned eight-bit
     * number.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public short readUnsignedByte() throws IOException {
<span class="fc" id="L281">        return (short) randomAccessFile.readUnsignedByte();</span>
    }

    /**
     * Reads a signed 16-bit number from this file. The method reads two byte
     * from this file, starting at the current file pointer. If the two bytes
     * read, in order, are b1 and b2, where each of the two values is between 0
     * and 255, inclusive, then the result is equal to: (short)(b1 &amp;lt;&amp;lt; 8 |
     * b2).
     * This method blocks until the two bytes are read, the end of the stream is
     * detected, or an exception is thrown.
     *
     * @return the next two bytes of this file, interpreted as a signed 16-bit
     * number.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public short readShort() throws IOException {
<span class="fc" id="L299">        return randomAccessFile.readShort();</span>
    }

    /**
     * Reads a signed 16-bit number from this file assuming that file is encoded
     * using provided endian type. If endian type is big endian type, then
     * natural binary order is preserved, otherwise byte order is reversed.
     * This method blocks until the two bytes of the 16-bit number are read, the
     * end of the stream is detected, or an exception is thrown.
     *
     * @param endianType Endian type. Big endian preserves natural binary order,
     *                   little endian reverses byte order.
     * @return the next two bytes of this file, interpreted as a signed 16-bit
     * number encoded in provided endian type.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public short readShort(final EndianType endianType) throws IOException {
<span class="fc" id="L317">        final var value = randomAccessFile.readShort();</span>
<span class="fc" id="L318">        return Util.fromEndianType(endianType, value);</span>
    }

    /**
     * Reads an unsigned 16-bit number from this file. This method reads two
     * bytes from this file, starting at the current file pointer. If the bytes
     * read, in order, are b1 and b2, where 0 &amp;lt;= b1, b2 &amp;lt;= 255, then the
     * result is equal to: (b1 &amp;lt;&amp;lt; 8) | b2.
     * This method blocks until the two bytes are read, the end of the stream is
     * detected, or an exception is thrown.
     *
     * @return the next two bytes of this file, interpreted as an unsigned
     * 16-bit integer.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public int readUnsignedShort() throws IOException {
<span class="fc" id="L335">        return randomAccessFile.readUnsignedShort();</span>
    }

    /**
     * Reads an unsigned 16-bit number from this file. This method reads two
     * bytes from this file, starting at the current file pointer and using
     * provided endian type. If endian type is big endian, then natural binary
     * order is preserved, otherwise byte order is reversed.
     * This method blocks until the two bytes are read, the end of the stream is
     * detected, or an exception is thrown.
     *
     * @param endianType Endian type. Big endian preserves natural binary order,
     *                   little endian reverses byte order.
     * @return the next two bytes of this file, interpreted as an unsigned
     * 16-bit integer.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public int readUnsignedShort(final EndianType endianType) throws IOException {
<span class="fc" id="L354">        final var streamValue = randomAccessFile.readShort();</span>
<span class="fc" id="L355">        final var value = Util.fromEndianType(endianType, streamValue);</span>

        // convert value to byte array
<span class="fc" id="L358">        final var firstShortByte = 0xff &amp; (value &gt;&gt; 8);</span>
<span class="fc" id="L359">        final var secondShortByte = 0xff &amp; ((value &lt;&lt; 8) &gt;&gt; 8);</span>

        // return it as integer
<span class="fc" id="L362">        return 0xffff &amp; ((firstShortByte &lt;&lt; 8) | secondShortByte);</span>
    }

    /**
     * Reads a signed 32-bit integer from this file. This method reads 4 bytes
     * from the file, starting at the current file pointer. If the bytes read,
     * in order, are b1, b2, b3, and b4, where 0 &amp;lt;= b1, b3, b4 &amp;lt;= 255, then
     * the result is equal to: (b1 &amp;lt;&amp;lt; 24) | (b2 &amp;lt;&amp;lt; 16) + (b3 &amp;lt;&amp;lt; 8) +
     * b4.
     * This method blocks until the four bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return the next four bytes of this file, interpreted as an int.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public int readInt() throws IOException {
<span class="fc" id="L379">        return randomAccessFile.readInt();</span>
    }

    /**
     * Reads a signed 32-bit integer from this file. This method reads 4 bytes
     * from the file, starting at the current file pointer and using provided
     * endian type. If endian type is big endian, then natural binary order is
     * preserved, otherwise byte order is reversed.
     * This method blocks until the four bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @param endianType Endian type. Big endian preserves natural binary order,
     *                   little endian reverses byte order.
     * @return the next four bytes of this file, interpreted as an int.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public int readInt(final EndianType endianType) throws IOException {
<span class="fc" id="L397">        final var value = randomAccessFile.readInt();</span>
<span class="fc" id="L398">        return Util.fromEndianType(endianType, value);</span>
    }

    /**
     * Reads an unsigned 32-bit integer from this file. This method reads 4
     * bytes from the file, starting at the current file pointer. If the bytes
     * read, in order, are b1, b2, b3, and b4, where 0 &amp;lt;= b1, b3, b4 &amp;lt;= 255,
     * then the result is equal to: (b1 &amp;lt;&amp;lt; 24) | (b2 &amp;lt;&amp;lt; 16) +
     * (b3 &amp;lt;&amp;lt; 8) + b4
     * This method blocks until the four bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return the next four bytes of this file, interpreted as a long.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public long readUnsignedInt() throws IOException {
<span class="fc" id="L415">        final var value = randomAccessFile.readInt();</span>

        // convert value to byte array
<span class="fc" id="L418">        final var firstIntByte = 0xff &amp; (value &gt;&gt; 24);</span>
<span class="fc" id="L419">        final var secondIntByte = 0xff &amp; ((value &lt;&lt; 8) &gt;&gt; 24);</span>
<span class="fc" id="L420">        final var thirdIntByte = 0xff &amp; ((value &lt;&lt; 16) &gt;&gt; 24);</span>
<span class="fc" id="L421">        final var fourthIntByte = 0xff &amp; ((value &lt;&lt; 24) &gt;&gt; 24);</span>

        // return it as integer
<span class="fc" id="L424">        return ((long) firstIntByte &lt;&lt; 24) | (secondIntByte &lt;&lt; 16) | (thirdIntByte &lt;&lt; 8) | fourthIntByte;</span>
    }

    /**
     * Reads an unsigned 32-bit integer from this file. This method reads 4
     * bytes from the file, starting at the current file pointer and using
     * provided endian type. If endian type is big endian, then natural binary
     * order is preserved, otherwise byte order is reversed.
     * This method blocks until the four bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @param endianType Endian type. Big endian preserves natural binary order,
     *                   little endian reverses byte order.
     * @return the next four bytes of this file, interpreted as an int.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public long readUnsignedInt(final EndianType endianType) throws IOException {
<span class="fc" id="L442">        final var streamValue = randomAccessFile.readInt();</span>
<span class="fc" id="L443">        final var value = Util.fromEndianType(endianType, streamValue);</span>

        // convert value to byte array
<span class="fc" id="L446">        final var firstIntByte = 0xff &amp; (value &gt;&gt; 24);</span>
<span class="fc" id="L447">        final var secondIntByte = 0xff &amp; ((value &lt;&lt; 8) &gt;&gt; 24);</span>
<span class="fc" id="L448">        final var thirdIntByte = 0xff &amp; ((value &lt;&lt; 16) &gt;&gt; 24);</span>
<span class="fc" id="L449">        final var fourthIntByte = 0xff &amp; ((value &lt;&lt; 24) &gt;&gt; 24);</span>

        // return it as integer
<span class="fc" id="L452">        return ((long) firstIntByte &lt;&lt; 24) | (secondIntByte &lt;&lt; 16) | (thirdIntByte &lt;&lt; 8) | fourthIntByte;</span>
    }

    /**
     * Reads a signed 64-bit integer from this file. This method reads eight
     * bytes from the file, starting at the current file pointer. If the bytes
     * read, in order, are b1, b2, b3, b4, b5, b6, b7, and b8, where:
     * 0 &amp;lt;= b1, b2, b3, b4. b5. b6. b7. b8 &amp;lt;= 255,
     * then the result is equal to:
     * ((long)b1 &amp;lt;&amp;lt; 56) + ((long)b2 &amp;lt;&amp;lt; 48)
     * + ((long)b3 &amp;lt;&amp;lt; 40) + ((long)b4 &amp;lt;&amp;lt; 32)
     * + ((long)b5 &amp;lt;&amp;lt; 24) + ((long)b6 &amp;lt;&amp;lt; 16)
     * + ((long)b7 &amp;lt;&amp;lt; 8) + b8
     * This method blocks until the eight bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return the next eight bytes of this file, interpreted as a long.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public long readLong() throws IOException {
<span class="fc" id="L473">        return randomAccessFile.readLong();</span>
    }

    /**
     * Reads a signed 64-bit integer from this file. This method reads eight
     * bytes from the file, starting at the current file pointer and using
     * provided endian type. If endian type is big endian, then natural binary
     * order is preserved, otherwise byte order is reversed.
     * This method blocks until the eight bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @param endianType Endian type. Big endian preserves natural binary order,
     *                   little endian reverses byte order.
     * @return the next eight bytes of this file, interpreted as a long
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public long readLong(final EndianType endianType) throws IOException {
<span class="fc" id="L491">        final var value = randomAccessFile.readLong();</span>
<span class="fc" id="L492">        return Util.fromEndianType(endianType, value);</span>
    }

    /**
     * Reads a float from this file. This method reads an int value, starting at
     * the current file pointer, as if by the readInt method and then converts
     * that in to a float using the intBitsToFloat method in class Float.
     * This method blocks until the four bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return the next four bytes of this file, interpreted as a float.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public float readFloat() throws IOException {
<span class="fc" id="L507">        return randomAccessFile.readFloat();</span>
    }

    /**
     * Reads a float from this file. This method reads four bytes using
     * provided endian type. If endian type is big endian, then natural binary
     * order is preserved, otherwise byte order is reversed.
     * This method blocks until the four bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @param endianType Endian type. Big endian preserves natural binary order,
     *                   little endian reverses byte order.
     * @return the next four bytes of this file, interpreted as a float.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public float readFloat(final EndianType endianType) throws IOException {
<span class="fc" id="L524">        final var value = randomAccessFile.readFloat();</span>
<span class="fc" id="L525">        return Util.fromEndianType(endianType, value);</span>
    }

    /**
     * Reads a double from this file. This method reads a long value, starting
     * at the current file pointer, as if by the readLong method and then
     * converts that long to a double using the longBitsToDouble method in class
     * Double.
     * This method blocks until the eight bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return the next eight bytes of this file, interpreted as a double.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public double readDouble() throws IOException {
<span class="fc" id="L541">        return randomAccessFile.readDouble();</span>
    }

    /**
     * Reads a double from this file. This method reads eight bytes using
     * provided endian type. If endian type is big endian, then natural binary
     * order is preserved, otherwise byte order is reversed.
     * This method blocks until the eight bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @param endianType Endian type. Big endian preserves natural binary order,
     *                   little endian reverses byte order.
     * @return the next eight bytes of this file, interpreted as a double.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public double readDouble(final EndianType endianType) throws IOException {
<span class="fc" id="L558">        final var value = randomAccessFile.readDouble();</span>
<span class="fc" id="L559">        return Util.fromEndianType(endianType, value);</span>
    }

    /**
     * Reads the next line of text from this file. This method successively
     * reads bytes from the file, starting at the current file pointer, until it
     * reaches a line terminator of the end of the file. Each byte is converted
     * into a character by taking the byte's value for the lower eight bits of
     * the character and setting the high eight bits of the character to zero.
     * This method does not, therefore, support the full Unicode character set.
     * A line of text is terminated by a carriage-return character ('\r'), a
     * newline character('\n'), a carriage-return character immediately followed
     * by a newline character, or the end of the file. Line-terminating
     * characters are discarded and are not included as part of the string
     * returned.
     * This method blocks until a newline character is read, a carriage return
     * and the byte following it are read (to see if it is a newline), the end
     * of the file is reached, or an exception is thrown.
     *
     * @return the next line of text from this file, or null if end of file is
     * encountered before even one byte is read.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public String readLine() throws IOException {
<span class="fc" id="L584">        return randomAccessFile.readLine();</span>
    }

    /**
     * Reads in a string from this file. The string has been encoded using a
     * modified UTF-8 format.
     * The first two bytes are read, starting from the current file pointer, as
     * if by readUnsignedShort. This value gives the number of following bytes
     * that are in the encoded string, not the length of the resulting string.
     * The following bytes are then interpreted as bytes encoding characters in
     * the modified UTF-8 format and are converted into characters.
     * This method blocks until all the bytes are read, the end of the stream is
     * detected, or an exception is thrown.
     *
     * @return a Unicode string.
     * @throws IOException if an I/O error occurs.
     */
    public String readUTF() throws IOException {
<span class="fc" id="L602">        return randomAccessFile.readUTF();</span>
    }

    /**
     * Sequentially reads characters starting at current file position until one
     * of the characters in provided pattern is found.
     * All characters read so far will be returned without including any of the
     * pattern characters.
     *
     * @param pattern Stop characters to stop reading when they are found.
     * @return String read so far until any of the pattern characters was found
     * or an empty string if the first character is contained in provided
     * pattern.
     * @throws IOException              if an I/O error occurs.
     * @throws IllegalArgumentException if no pattern characters are provided.
     */
    @Override
    public String readUntilAnyOfTheseCharactersIsFound(final String pattern) throws IOException {
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">        if (pattern.isEmpty()) {</span>
<span class="nc" id="L621">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L624">        final var buffer = new StringBuilder();</span>
<span class="fc" id="L625">        final var charBuffer = new byte[1];</span>
        String character;
<span class="fc bfc" id="L627" title="All 2 branches covered.">        while (randomAccessFile.read(charBuffer) == 1) {</span>
<span class="fc" id="L628">            character = new String(charBuffer);</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">            if (pattern.contains(character)) {</span>
                // character found
<span class="fc" id="L631">                break;</span>
            }
            // add character to output buffer
<span class="fc" id="L634">            buffer.append(character);</span>
        }

<span class="fc" id="L637">        return buffer.toString();</span>
    }

    /**
     * Writes a boolean to the file as a one-byte value. The value true is
     * written out as the value (byte)1; the value false is written out as the
     * value (byte)0. The write starts at the current position of the file
     * pointer.
     *
     * @param v a boolean value to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeBoolean(final boolean v) throws IOException {
<span class="fc" id="L651">        randomAccessFile.writeBoolean(v);</span>
<span class="fc" id="L652">    }</span>

    /**
     * Writes a byte to the file as a one-byte value. The write starts at the
     * current position of the file pointer.
     *
     * @param v a byte value to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeByte(final byte v) throws IOException {
<span class="fc" id="L663">        randomAccessFile.writeByte(v);</span>
<span class="fc" id="L664">    }</span>

    /**
     * Writes provided value in the range 0-255 as an unsigned byte. The write
     * starts at the current position of the file pointer.
     *
     * @param v a value to be written as an unsigned byte.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeUnsignedByte(final short v) throws IOException {
<span class="fc" id="L675">        final var data = (byte) (0xff &amp; v);</span>
<span class="fc" id="L676">        randomAccessFile.writeByte(data);</span>
<span class="fc" id="L677">    }</span>

    /**
     * Writes a short to the file as two bytes, high byte first. The write
     * starts at the current position of the file pointer.
     *
     * @param v a short to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeShort(final short v) throws IOException {
<span class="fc" id="L688">        randomAccessFile.writeShort(v);</span>
<span class="fc" id="L689">    }</span>

    /**
     * Writes a short to the file as two bytes using provided endian type.
     * If endian type is big endian, then natural byte order is preserved (and
     * high byte is written first), if little endian order is chosen, then byte
     * order is reversed.
     *
     * @param v          a short to be written.
     * @param endianType endian type. If it is big endian, natural byte order is
     *                   preserved, otherwise byte order is reversed.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeShort(final short v, final EndianType endianType) throws IOException {
<span class="fc" id="L704">        final var value = Util.toEndianType(endianType, v);</span>
<span class="fc" id="L705">        randomAccessFile.writeShort(value);</span>
<span class="fc" id="L706">    }</span>

    /**
     * Writes an unsigned short to the file as two bytes, high byte first.
     * Provided integer value is converted to an unsigned short by taking into
     * account only the two lower bytes. The write starts at the current
     * position of the file pointer.
     *
     * @param v an unsigned short to be written (int is converted to unsigned
     *          short).
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeUnsignedShort(final int v) throws IOException {
<span class="fc" id="L720">        final var firstShortByte = 0xff &amp; (v &gt;&gt; 8);</span>
<span class="fc" id="L721">        final var secondShortByte = 0xff &amp; ((v &lt;&lt; 8) &gt;&gt; 8);</span>

<span class="fc" id="L723">        final var value = (short) ((firstShortByte &lt;&lt; 8) | secondShortByte);</span>

<span class="fc" id="L725">        randomAccessFile.writeShort(value);</span>
<span class="fc" id="L726">    }</span>

    /**
     * Writes an unsigned short to the file as two bytes, using provided endian
     * type.
     * Provided integer value is converted to an unsigned short by taking into
     * account only the two lower bytes.
     * If endian type is big endian, then natural byte order is preserved (and
     * high byte is written first), if little endian order is chosen, then byte
     * order is reversed.
     * The write starts at the current position of the file pointer.
     *
     * @param v          an unsigned short to be written (int is converted to unsigned
     *                   short).
     * @param endianType endian type. If it is big endian, natural byte order is
     *                   preserved, otherwise byte order is reversed.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeUnsignedShort(final int v, final EndianType endianType) throws IOException {
<span class="fc" id="L746">        final var firstShortByte = 0xff &amp; (v &gt;&gt; 8);</span>
<span class="fc" id="L747">        final var secondShortByte = 0xff &amp; ((v &lt;&lt; 8) &gt;&gt; 8);</span>

<span class="fc" id="L749">        final var machineValue = (short) ((firstShortByte &lt;&lt; 8) | secondShortByte);</span>
<span class="fc" id="L750">        final var value = Util.toEndianType(endianType, machineValue);</span>

<span class="fc" id="L752">        randomAccessFile.writeShort(value);</span>
<span class="fc" id="L753">    }</span>

    /**
     * Writes an int to the file as four bytes, high byte first. The write
     * starts at the current position of the file pointer.
     *
     * @param v an int to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeInt(final int v) throws IOException {
<span class="fc" id="L764">        randomAccessFile.writeInt(v);</span>
<span class="fc" id="L765">    }</span>

    /**
     * Writes an int to the file as four bytes, using provided endian type.
     * If endian type is big endian, then natural byte order is preserved (and
     * high byte is written first), if little endian order is chosen, then byte
     * order is reversed.
     * The write starts at the current position of the file pointer.
     *
     * @param v          an int to be written.
     * @param endianType endian type. If it is big endian, natural byte order is
     *                   preserved, otherwise byte order is reversed.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeInt(final int v, final EndianType endianType) throws IOException {
<span class="fc" id="L781">        final var value = Util.toEndianType(endianType, v);</span>
<span class="fc" id="L782">        randomAccessFile.writeInt(value);</span>
<span class="fc" id="L783">    }</span>

    /**
     * Writes an unsigned int to the file as four bytes, high byte first.
     * Provided integer value is converted to an unsigned int by taking into
     * account only the four lower bytes. The write starts at the current
     * position of the file pointer.
     *
     * @param v an unsigned int to be written (long is converted to unsigned
     *          int).
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeUnsignedInt(final long v) throws IOException {
<span class="fc" id="L797">        final var firstIntByte = (int) (0xff &amp; (v &gt;&gt; 24));</span>
<span class="fc" id="L798">        final var secondIntByte = (int) (0xff &amp; ((v &lt;&lt; 8) &gt;&gt; 24));</span>
<span class="fc" id="L799">        final var thirdIntByte = (int) (0xff &amp; ((v &lt;&lt; 16) &gt;&gt; 24));</span>
<span class="fc" id="L800">        final var fourthIntByte = (int) (0xff &amp; ((v &lt;&lt; 24) &gt;&gt; 24));</span>

<span class="fc" id="L802">        final var value = (firstIntByte &lt;&lt; 24) | (secondIntByte &lt;&lt; 16) | (thirdIntByte &lt;&lt; 8) | fourthIntByte;</span>

<span class="fc" id="L804">        randomAccessFile.writeInt(value);</span>
<span class="fc" id="L805">    }</span>

    /**
     * Writes an unsigned int to the file as four bytes, using provided endian
     * type.
     * Provided integer value is converted to an unsigned int by taking into
     * account only the four lower bytes.
     * If endian type is big endian, then natural byte order is preserved (and
     * high byte is written first), if little endian order is chosen, then byte
     * order is reversed.
     * The write starts at the current position of the file pointer.
     *
     * @param v          an unsigned int to be written (long is converted to unsigned
     *                   short).
     * @param endianType endian type. If it is big endian, natural byte order is
     *                   preserved, otherwise byte order is reversed.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeUnsignedInt(final long v, final EndianType endianType) throws IOException {
<span class="fc" id="L825">        final var firstIntByte = (int) (0xff &amp; (v &gt;&gt; 24));</span>
<span class="fc" id="L826">        final var secondIntByte = (int) (0xff &amp; ((v &lt;&lt; 8) &gt;&gt; 24));</span>
<span class="fc" id="L827">        final var thirdIntByte = (int) (0xff &amp; ((v &lt;&lt; 16) &gt;&gt; 24));</span>
<span class="fc" id="L828">        final var fourthIntByte = (int) (0xff &amp; ((v &lt;&lt; 24) &gt;&gt; 24));</span>

<span class="fc" id="L830">        final var machineValue = (firstIntByte &lt;&lt; 24) | (secondIntByte &lt;&lt; 16) | (thirdIntByte &lt;&lt; 8) | fourthIntByte;</span>
<span class="fc" id="L831">        final var value = Util.toEndianType(endianType, machineValue);</span>

<span class="fc" id="L833">        randomAccessFile.writeInt(value);</span>
<span class="fc" id="L834">    }</span>

    /**
     * Writes a long to the file as eight bytes, high byte first. The write
     * starts at the current position of the file pointer.
     *
     * @param v a long to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeLong(final long v) throws IOException {
<span class="fc" id="L845">        randomAccessFile.writeLong(v);</span>
<span class="fc" id="L846">    }</span>

    /**
     * Writes a long to the file as eight bytes, using provided endian type.
     * If endian type is big endian, then natural byte order is preserved (and
     * high byte is written first), if little endian order is chosen, then byte
     * order is reversed.
     * The write starts at the current position of the file pointer.
     *
     * @param v          a long to be written.
     * @param endianType endian type. If it is big endian, natural byte order is
     *                   preserved, otherwise byte order is reversed.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeLong(final long v, final EndianType endianType) throws IOException {
<span class="fc" id="L862">        final var value = Util.toEndianType(endianType, v);</span>
<span class="fc" id="L863">        randomAccessFile.writeLong(value);</span>
<span class="fc" id="L864">    }</span>

    /**
     * Converts the float argument to an int using the floatToIntBits method in
     * class Float, and then write that int value to the file as a four-byte
     * quantity, high byte first. The write starts at the current position of
     * the file pointer.
     *
     * @param v a float value to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeFloat(final float v) throws IOException {
<span class="fc" id="L877">        randomAccessFile.writeFloat(v);</span>
<span class="fc" id="L878">    }</span>

    /**
     * Converts the float argument to an int using the floatToIntBits method in
     * class Float, and then write that int value to the file as a four-byte
     * quantity, using provided endian type.
     * If endian type is big endian, then natural byte order is preserved (and
     * high byte is written first), if little endian order is chosen, then byte
     * order is reversed.
     * The write starts at the current position of the file pointer.
     *
     * @param v          a float value to be written.
     * @param endianType endian type. If it is big endian, natural byte order is
     *                   preserved, otherwise byte order is reversed.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeFloat(final float v, final EndianType endianType) throws IOException {
<span class="fc" id="L896">        final var value = Util.toEndianType(endianType, v);</span>
<span class="fc" id="L897">        randomAccessFile.writeFloat(value);</span>
<span class="fc" id="L898">    }</span>

    /**
     * Converts the double argument to a long using the doubleToLongBits method
     * in class Double, and then writes that long value to the file as an eight
     * byte quantity, high byte first. The write starts at the current position
     * of the file pointer.
     *
     * @param v a double value to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeDouble(final double v) throws IOException {
<span class="fc" id="L911">        randomAccessFile.writeDouble(v);</span>
<span class="fc" id="L912">    }</span>

    /**
     * Converts the double argument to a long using the doubleToLongBits method
     * in class Double, and then writes that long value to the file as an eight
     * byte quantity, using provided endian type.
     * If endian type is big endian, then natural byte order is preserved (and
     * high byte is written first), if little endian order is chosen, then byte
     * order is reversed.
     * The write starts at the current position of the file pointer.
     *
     * @param v          a double value to be written.
     * @param endianType endian type. If it is big endian, natural byte order is
     *                   preserved, otherwise byte order is reversed.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeDouble(final double v, final EndianType endianType) throws IOException {
<span class="fc" id="L930">        final var value = Util.toEndianType(endianType, v);</span>
<span class="fc" id="L931">        randomAccessFile.writeDouble(value);</span>
<span class="fc" id="L932">    }</span>

    /**
     * Writes the string to the file as a sequence of bytes. Each character in
     * the string is written out, in sequence, by discarding its high eight
     * bits. The write starts at the current position of the file pointer.
     *
     * @param s a string of bytes to be written.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeASCII(final String s) throws IOException {
<span class="fc" id="L944">        randomAccessFile.writeBytes(s);</span>
<span class="fc" id="L945">    }</span>

    /**
     * Writes a string to the file using modified UTF-8 encoding in a machine-
     * independent manner.
     * First, two bytes are written to the file, starting at the current file
     * pointer, as if by the writeShort method giving the number of bytes to
     * follow. This value is the number of bytes actually written out, not the
     * length of the string.
     * Following the length, each character of the string is output, in
     * sequence, using the modified UTF-8 encoding for each character.
     *
     * @param str a string to be written.
     * @throws IOException if an I/O error occurs.
     */
    public void writeUTF(final String str) throws IOException {
<span class="fc" id="L961">        randomAccessFile.writeUTF(str);</span>
<span class="fc" id="L962">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>