<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LoaderPLY.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry-io</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry.io</a> &gt; <span class="el_source">LoaderPLY.java</span></div><h1>LoaderPLY.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry.io;

import com.irurueta.geometry.InhomogeneousPoint3D;
import com.irurueta.geometry.Point3D;
import com.irurueta.geometry.Triangulator3D;
import com.irurueta.geometry.TriangulatorException;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Loads PLY files.
 * This class is meant to read PLY files using an iterative process to read
 * the file in small pieces of data.
 * Because the file is loaded in small pieces, this class has a low memory
 * impact. Besides parameters such as maxVerticesInChunk or maxStreamPositions
 * can be adjusted in order to increase or reduce memory usage at the expense of
 * performance (the greater the memory usage the better the performance).
 * This class needs random access to file positions, and for that reason it
 * cannot be used with streams.
 * This class is based in the work of:
 * &lt;a href=&quot;http://w3.impa.br/~diego/software/rply/&quot;&gt;http://w3.impa.br/~diego/software/rply/&lt;/a&gt;
 */
public class LoaderPLY extends Loader {
    /**
     * Size of internal buffer where bytes from stream of data read into.
     * This size (8 bytes) is meant to be able to fit any data type.
     *
     * @see DataTypePLY
     */
    public static final int BUFFER_SIZE = 8;

    /**
     * Constant defining maximum number of vertices to be stored in a single
     * data chunk.
     * By default, this is the maximum values stored in a short 65535. This is
     * so that data chunks can be compatible with technologies such as openGL
     * where vertex indices are short values, and hence only 65535 vertices can
     * be indexed at a time.
     */
    public static final int DEFAULT_MAX_VERTICES_IN_CHUNK = 0xffff;

    /**
     * Minimum allowed value for maximum vertices in a chunk. At least one
     * vertex must be contained on a data chunk, for that reason this constant
     * is 1.
     */
    public static final int MIN_MAX_VERTICES_IN_CHUNK = 1;

    /**
     * Constant defining if by default duplicate vertices are allowed in a data
     * chunk. By allowing duplicate vertices, PLY loading can be speed up a
     * little bit at the expense of getting larger sets of data which will
     * contain redundant vertices. If your environment is memory constrained,
     * this should be disabled. By default, it is disabled.
     */
    public static final boolean DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK = false;

    /**
     * Constant defining default maximum number of stream positions to be
     * cached.
     * This loader keeps track of a set of stream positions that have been
     * parsed on ASCII mode. By keeping a cache of positions loading times can
     * be largely reduced at the expense of using more memory during loading.
     * By default, this is set to 1000000 positions.
     * This only has effect on ASCII PLY files. For binary PLY files this
     * constant is ignored.
     */
    public static final int DEFAULT_MAX_STREAM_POSITIONS = 1000000;

    /**
     * Constant defining minimum allowed value for maximum stream positions.
     */
    public static final int MIN_STREAM_POSITIONS = 1;

    /**
     * Constant defining when progress change should be notified. When progress
     * is increased by this value from previous notification, then progress will
     * be notified again.
     */
    public static final float PROGRESS_DELTA = 0.01f;

    /**
     * Keeps PLY header data.
     */
    private HeaderPLY header;

    /**
     * Boolean indicating if file is a valid PLY stream of data.
     */
    private boolean validStream;

    /**
     * Boolean indicating whether validity of file has already been checked.
     */
    private boolean validityChecked;

    /**
     * Iterator currently loading provided file.
     */
    private LoaderIteratorPLY loaderIterator;

    /**
     * Indicates maximum number of vertices to keep in a chunk of data.
     * By default, this is the maximum values stored in a short 65535. This is
     * so that data chunks can be compatible with technologies such as openGL
     * where vertex indices are short values, and hence only 65535 vertices can
     * be indexed at a time.
     */
    private int maxVerticesInChunk;

    /**
     * Indicates whether duplicate vertices in a chunk are allowed. By allowing
     * duplicate vertices, PLY loading can be speed up a little bit at the
     * expense of getting larger sets of data which will contain redundant
     * vertices. If your environment is memory constrained, this should be
     * disabled. By default, it is disabled.
     */
    private boolean allowDuplicateVerticesInChunk;

    /**
     * Maximum number of stream positions to be cached.
     * This loader keeps track of a set of stream positions that have been
     * parsed on ASCII mode. By keeping a cache of positions loading times can
     * be largely reduced at the expense of using more memory during loading.
     * By default, this is set to 1000000 positions.
     * This only has effect on ASCII PLY files. For binary PLY files this
     * setting is ignored.
     */
    private long maxStreamPositions;

    /**
     * Constructor.
     */
<span class="fc" id="L154">    public LoaderPLY() {</span>
<span class="fc" id="L155">        reader = null;</span>
<span class="fc" id="L156">        header = null;</span>
<span class="fc" id="L157">        validStream = false;</span>
<span class="fc" id="L158">        validityChecked = false;</span>
<span class="fc" id="L159">        loaderIterator = null;</span>
<span class="fc" id="L160">        maxVerticesInChunk = DEFAULT_MAX_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L161">        allowDuplicateVerticesInChunk = DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L162">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L163">    }</span>

    /**
     * Constructor.
     *
     * @param maxVerticesInChunk Indicates maximum number of vertices to keep in
     *                           a chunk of data.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     */
<span class="fc" id="L173">    public LoaderPLY(final int maxVerticesInChunk) {</span>
<span class="fc" id="L174">        reader = null;</span>
<span class="fc" id="L175">        header = null;</span>
<span class="fc" id="L176">        validStream = false;</span>
<span class="fc" id="L177">        validityChecked = false;</span>
<span class="fc" id="L178">        loaderIterator = null;</span>
<span class="fc" id="L179">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L180">        allowDuplicateVerticesInChunk = DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L181">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L182">    }</span>

    /**
     * Constructor.
     *
     * @param maxVerticesInChunk            Indicates maximum number of vertices to keep in
     *                                      a chunk of data.
     * @param allowDuplicateVerticesInChunk Indicates whether duplicate vertices
     *                                      in a chunk are allowed.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     */
<span class="fc" id="L194">    public LoaderPLY(final int maxVerticesInChunk, final boolean allowDuplicateVerticesInChunk) {</span>
<span class="fc" id="L195">        reader = null;</span>
<span class="fc" id="L196">        header = null;</span>
<span class="fc" id="L197">        validStream = false;</span>
<span class="fc" id="L198">        validityChecked = false;</span>
<span class="fc" id="L199">        loaderIterator = null;</span>
<span class="fc" id="L200">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L201">        internalSetAllowDuplicateVerticesInChunk(allowDuplicateVerticesInChunk);</span>
<span class="fc" id="L202">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L203">    }</span>

    /**
     * Constructor.
     *
     * @param maxVerticesInChunk            Indicates maximum number of vertices to keep in
     *                                      a chunk of data.
     * @param allowDuplicateVerticesInChunk Indicates whether duplicate vertices
     *                                      in a chunk are allowed.
     * @param maxStreamPositions            Maximum number of stream positions to be
     *                                      cached.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK or if maximum stream positions is
     *                                  smaller than MIN_STREAM_POSITIONS.
     */
    public LoaderPLY(final int maxVerticesInChunk, final boolean allowDuplicateVerticesInChunk,
<span class="fc" id="L219">                     final long maxStreamPositions) {</span>
<span class="fc" id="L220">        reader = null;</span>
<span class="fc" id="L221">        header = null;</span>
<span class="fc" id="L222">        validStream = false;</span>
<span class="fc" id="L223">        validityChecked = false;</span>
<span class="fc" id="L224">        loaderIterator = null;</span>
<span class="fc" id="L225">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L226">        internalSetAllowDuplicateVerticesInChunk(allowDuplicateVerticesInChunk);</span>
<span class="fc" id="L227">        internalSetMaxStreamPositions(maxStreamPositions);</span>
<span class="fc" id="L228">    }</span>

    /**
     * Constructor.
     *
     * @param f file to be loaded.
     * @throws IOException if file does not exist or cannot be loaded.
     */
    public LoaderPLY(final File f) throws IOException {
<span class="fc" id="L237">        super(f);</span>
<span class="fc" id="L238">        header = null;</span>
<span class="fc" id="L239">        validStream = false;</span>
<span class="fc" id="L240">        validityChecked = false;</span>
<span class="fc" id="L241">        loaderIterator = null;</span>
<span class="fc" id="L242">        maxVerticesInChunk = DEFAULT_MAX_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L243">        allowDuplicateVerticesInChunk = DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L244">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L245">    }</span>

    /**
     * Constructor.
     *
     * @param f                  file to be loaded.
     * @param maxVerticesInChunk Indicates maximum number of vertices to keep in
     *                           a chunk of data.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     * @throws IOException              if file does not exist or cannot be loaded.
     */
    public LoaderPLY(final File f, final int maxVerticesInChunk) throws IOException {
<span class="fc" id="L258">        super(f);</span>
<span class="fc" id="L259">        header = null;</span>
<span class="fc" id="L260">        validStream = false;</span>
<span class="fc" id="L261">        validityChecked = false;</span>
<span class="fc" id="L262">        loaderIterator = null;</span>
<span class="fc" id="L263">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L264">        allowDuplicateVerticesInChunk = DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L265">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L266">    }</span>

    /**
     * Constructor.
     *
     * @param f                             file to be loaded.
     * @param maxVerticesInChunk            Indicates maximum number of vertices to keep in
     *                                      a chunk of data.
     * @param allowDuplicateVerticesInChunk Indicates whether duplicate vertices
     *                                      in a chunk are allowed.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     * @throws IOException              if file does not exist or cannot be loaded.
     */
    public LoaderPLY(final File f, final int maxVerticesInChunk, final boolean allowDuplicateVerticesInChunk)
            throws IOException {
<span class="fc" id="L282">        super(f);</span>
<span class="fc" id="L283">        header = null;</span>
<span class="fc" id="L284">        validStream = false;</span>
<span class="fc" id="L285">        validityChecked = false;</span>
<span class="fc" id="L286">        loaderIterator = null;</span>
<span class="fc" id="L287">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L288">        internalSetAllowDuplicateVerticesInChunk(allowDuplicateVerticesInChunk);</span>
<span class="fc" id="L289">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L290">    }</span>

    /**
     * Constructor.
     *
     * @param f                             file to be loaded.
     * @param maxVerticesInChunk            Indicates maximum number of vertices to keep in
     *                                      a chunk of data.
     * @param allowDuplicateVerticesInChunk Indicates whether duplicate vertices
     *                                      in a chunk are allowed.
     * @param maxStreamPositions            Maximum number of stream positions to be
     *                                      cached.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK or if maximum stream positions is
     *                                  smaller than MIN_STREAM_POSITIONS.
     * @throws IOException              if file does not exist or cannot be loaded.
     */
    public LoaderPLY(final File f, final int maxVerticesInChunk, final boolean allowDuplicateVerticesInChunk,
                     final long maxStreamPositions) throws IOException {
<span class="fc" id="L309">        super(f);</span>
<span class="fc" id="L310">        header = null;</span>
<span class="fc" id="L311">        validStream = false;</span>
<span class="fc" id="L312">        validityChecked = false;</span>
<span class="fc" id="L313">        loaderIterator = null;</span>
<span class="fc" id="L314">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L315">        internalSetAllowDuplicateVerticesInChunk(allowDuplicateVerticesInChunk);</span>
<span class="fc" id="L316">        internalSetMaxStreamPositions(maxStreamPositions);</span>
<span class="fc" id="L317">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to notify start, end and progress events.
     */
    public LoaderPLY(final LoaderListener listener) {
<span class="fc" id="L325">        super(listener);</span>
<span class="fc" id="L326">        reader = null;</span>
<span class="fc" id="L327">        header = null;</span>
<span class="fc" id="L328">        validStream = false;</span>
<span class="fc" id="L329">        validityChecked = false;</span>
<span class="fc" id="L330">        loaderIterator = null;</span>
<span class="fc" id="L331">        maxVerticesInChunk = DEFAULT_MAX_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L332">        allowDuplicateVerticesInChunk = DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L333">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L334">    }</span>

    /**
     * Constructor.
     *
     * @param listener           listener to notify start, end and progress events.
     * @param maxVerticesInChunk Indicates maximum number of vertices to keep in
     *                           a chunk of data.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     */
    public LoaderPLY(final LoaderListener listener, final int maxVerticesInChunk) {
<span class="fc" id="L346">        super(listener);</span>
<span class="fc" id="L347">        reader = null;</span>
<span class="fc" id="L348">        header = null;</span>
<span class="fc" id="L349">        validStream = false;</span>
<span class="fc" id="L350">        validityChecked = false;</span>
<span class="fc" id="L351">        loaderIterator = null;</span>
<span class="fc" id="L352">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L353">        allowDuplicateVerticesInChunk = DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L354">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L355">    }</span>

    /**
     * Constructor.
     *
     * @param listener                      listener to notify start, end and progress events.
     * @param maxVerticesInChunk            Indicates maximum number of vertices to keep in
     *                                      a chunk of data.
     * @param allowDuplicateVerticesInChunk Indicates whether duplicate vertices
     *                                      in a chunk are allowed.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     */
    public LoaderPLY(final LoaderListener listener, final int maxVerticesInChunk,
                     final boolean allowDuplicateVerticesInChunk) {
<span class="fc" id="L370">        super(listener);</span>
<span class="fc" id="L371">        reader = null;</span>
<span class="fc" id="L372">        header = null;</span>
<span class="fc" id="L373">        validStream = false;</span>
<span class="fc" id="L374">        validityChecked = false;</span>
<span class="fc" id="L375">        loaderIterator = null;</span>
<span class="fc" id="L376">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L377">        internalSetAllowDuplicateVerticesInChunk(allowDuplicateVerticesInChunk);</span>
<span class="fc" id="L378">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L379">    }</span>

    /**
     * Constructor.
     *
     * @param listener                      listener to notify start, end and progress events.
     * @param maxVerticesInChunk            Indicates maximum number of vertices to keep in
     *                                      a chunk of data.
     * @param allowDuplicateVerticesInChunk Indicates whether duplicate vertices
     *                                      in a chunk are allowed.
     * @param maxStreamPositions            Maximum number of stream positions to be
     *                                      cached.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK or if maximum stream positions is
     *                                  smaller than MIN_STREAM_POSITIONS.
     */
    public LoaderPLY(final LoaderListener listener, final int maxVerticesInChunk,
                     final boolean allowDuplicateVerticesInChunk, final long maxStreamPositions) {
<span class="fc" id="L397">        super(listener);</span>
<span class="fc" id="L398">        reader = null;</span>
<span class="fc" id="L399">        header = null;</span>
<span class="fc" id="L400">        validStream = false;</span>
<span class="fc" id="L401">        validityChecked = false;</span>
<span class="fc" id="L402">        loaderIterator = null;</span>
<span class="fc" id="L403">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L404">        internalSetAllowDuplicateVerticesInChunk(allowDuplicateVerticesInChunk);</span>
<span class="fc" id="L405">        internalSetMaxStreamPositions(maxStreamPositions);</span>
<span class="fc" id="L406">    }</span>

    /**
     * Constructor.
     *
     * @param f        file to be loaded.
     * @param listener listener to notify start, end and progress events.
     * @throws IOException if file does not exist or cannot be loaded.
     */
    public LoaderPLY(final File f, final LoaderListener listener) throws IOException {
<span class="fc" id="L416">        super(f, listener);</span>
<span class="fc" id="L417">        header = null;</span>
<span class="fc" id="L418">        validStream = false;</span>
<span class="fc" id="L419">        validityChecked = false;</span>
<span class="fc" id="L420">        loaderIterator = null;</span>
<span class="fc" id="L421">        maxVerticesInChunk = DEFAULT_MAX_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L422">        allowDuplicateVerticesInChunk = DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L423">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L424">    }</span>

    /**
     * Constructor.
     *
     * @param f                  file to be loaded.
     * @param listener           listener to notify start, end and progress events.
     * @param maxVerticesInChunk Indicates maximum number of vertices to keep in
     *                           a chunk of data.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     * @throws IOException              if file does not exist or cannot be loaded.
     */
    public LoaderPLY(final File f, final LoaderListener listener, final int maxVerticesInChunk) throws IOException {
<span class="fc" id="L438">        super(f, listener);</span>
<span class="fc" id="L439">        header = null;</span>
<span class="fc" id="L440">        validStream = false;</span>
<span class="fc" id="L441">        validityChecked = false;</span>
<span class="fc" id="L442">        loaderIterator = null;</span>
<span class="fc" id="L443">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L444">        allowDuplicateVerticesInChunk = DEFAULT_ALLOW_DUPLICATE_VERTICES_IN_CHUNK;</span>
<span class="fc" id="L445">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L446">    }</span>

    /**
     * Constructor.
     *
     * @param f                             file to be loaded.
     * @param listener                      listener to notify start, end and progress events.
     * @param maxVerticesInChunk            Indicates maximum number of vertices to keep in
     *                                      a chunk of data.
     * @param allowDuplicateVerticesInChunk Indicates whether duplicate vertices
     *                                      in a chunk are allowed.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     * @throws IOException              if file does not exist or cannot be loaded.
     */
    public LoaderPLY(final File f, final LoaderListener listener, final int maxVerticesInChunk,
                     final boolean allowDuplicateVerticesInChunk) throws IOException {
<span class="fc" id="L463">        super(f, listener);</span>
<span class="fc" id="L464">        header = null;</span>
<span class="fc" id="L465">        validStream = false;</span>
<span class="fc" id="L466">        validityChecked = false;</span>
<span class="fc" id="L467">        loaderIterator = null;</span>
<span class="fc" id="L468">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L469">        internalSetAllowDuplicateVerticesInChunk(allowDuplicateVerticesInChunk);</span>
<span class="fc" id="L470">        maxStreamPositions = DEFAULT_MAX_STREAM_POSITIONS;</span>
<span class="fc" id="L471">    }</span>

    /**
     * Constructor.
     *
     * @param f                             file to be loaded.
     * @param listener                      listener to notify start, end and progress events.
     * @param maxVerticesInChunk            Indicates maximum number of vertices to keep in
     *                                      a chunk of data.
     * @param allowDuplicateVerticesInChunk Indicates whether duplicate vertices
     *                                      in a chunk are allowed.
     * @param maxStreamPositions            Maximum number of stream positions to be
     *                                      cached.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK or if maximum stream positions is
     *                                  smaller than MIN_STREAM_POSITIONS.
     * @throws IOException              if file does not exist or cannot be loaded.
     */
    public LoaderPLY(final File f, final LoaderListener listener, final int maxVerticesInChunk,
                     final boolean allowDuplicateVerticesInChunk, final long maxStreamPositions) throws IOException {
<span class="fc" id="L491">        super(f, listener);</span>
<span class="fc" id="L492">        header = null;</span>
<span class="fc" id="L493">        validStream = false;</span>
<span class="fc" id="L494">        validityChecked = false;</span>
<span class="fc" id="L495">        loaderIterator = null;</span>
<span class="fc" id="L496">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L497">        internalSetAllowDuplicateVerticesInChunk(allowDuplicateVerticesInChunk);</span>
<span class="fc" id="L498">        internalSetMaxStreamPositions(maxStreamPositions);</span>
<span class="fc" id="L499">    }</span>

    /**
     * Returns maximum number of vertices to keep in a chunk of data.
     * By default, this is the maximum values stored in a short is 65535. This is
     * so that data chunks can be compatible with technologies such as openGL
     * where vertex indices are short values, and hence only 65535 vertices can
     * be indexed at a time.
     *
     * @return Maximum number of vertices to keep in a chunk of data.
     */
    public int getMaxVerticesInChunk() {
<span class="fc" id="L511">        return maxVerticesInChunk;</span>
    }

    /**
     * Sets maximum number of vertices to keep in a chunk of data.
     *
     * @param maxVerticesInChunk Indicates maximum number of vertices to keep in
     *                           a chunk of data.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     * @throws LockedException          Raised if this instance is locked because loading
     *                                  is in progress.
     */
    public void setMaxVerticesInChunk(final int maxVerticesInChunk) throws LockedException {
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L526">            throw new LockedException();</span>
        }
<span class="fc" id="L528">        internalSetMaxVerticesInChunk(maxVerticesInChunk);</span>
<span class="fc" id="L529">    }</span>

    /**
     * Determines whether duplicate vertices in a chunk are allowed. By allowing
     * duplicate vertices, PLY loading can be speed up a little bit at the
     * expense of getting larger sets of data which will contain redundant
     * vertices. If your environment is memory constrained, this should be
     * disabled. By default, it is disabled.
     *
     * @return Determines whether duplicate vertices in a chunk are allowed.
     */
    public boolean areDuplicateVerticesInChunkAllowed() {
<span class="fc" id="L541">        return allowDuplicateVerticesInChunk;</span>
    }

    /**
     * Sets whether duplicate vertices in a chunk are allowed. By allowing
     * duplicate vertices, PLY loading can be speed up a little bit at the
     * expense of getting larger sets of data which will contain redundant
     * vertices. If your environment is memory constrained, this should be
     * disabled. By default, it is disabled.
     *
     * @param allow Indicates whether duplicates will be allowed or not.
     * @throws LockedException Raised if this instance is locked because loading
     *                         is in progress.
     */
    public void setAllowDuplicateVerticesInChunk(final boolean allow) throws LockedException {
<span class="fc bfc" id="L556" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L557">            throw new LockedException();</span>
        }
<span class="fc" id="L559">        internalSetAllowDuplicateVerticesInChunk(allow);</span>
<span class="fc" id="L560">    }</span>

    /**
     * Returns maximum number of stream positions to be cached.
     * This loader keeps track of a set of stream positions that have been
     * parsed on ASCII mode. By keeping a cache of positions loading times can
     * be largely reduced at the expense of using more memory during loading.
     * By default, this is set to 1000000 positions.
     * This only has effect on ASCII PLY files. For binary PLY files this
     * setting is ignored.
     *
     * @return maximum number of stream positions to be cached.
     */
    public long getMaxStreamPositions() {
<span class="fc" id="L574">        return maxStreamPositions;</span>
    }

    /**
     * Sets maximum number of stream positions to be cached.
     * This loader keeps track of a set of stream positions that have been
     * parsed on ASCII mode. By keeping a cache of positions loading times can
     * be largely reduced at the expense of using more memory during loading.
     * By default, this is set to 1000000 positions.
     * This only has effect on ASCII PLY files. For binary PLY files this
     * setting is ignored.
     *
     * @param maxStreamPositions Maximum number of stream positions to be cached.
     * @throws IllegalArgumentException Raised if provided value is lower than
     *                                  DEFAULT_MAX_STREAM_POSITIONS.
     * @throws LockedException          Raised if this instance is locked because loading
     *                                  is in progress.
     */
    public void setMaxStreamPositions(final long maxStreamPositions) throws LockedException {
<span class="fc bfc" id="L593" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L594">            throw new LockedException();</span>
        }
<span class="fc" id="L596">        internalSetMaxStreamPositions(maxStreamPositions);</span>
<span class="fc" id="L597">    }</span>

    /**
     * Indicates it this loader has enough parameters to start the loading
     * process.
     *
     * @return True if ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="fc" id="L607">        return hasFile();</span>
    }

    /**
     * Returns mesh format supported by this loader, which is PLY_MESH_FORMAT.
     *
     * @return Format supported by this loader, which is PLY_MESH_FORMAT.
     */
    @Override
    public MeshFormat getMeshFormat() {
<span class="fc" id="L617">        return MeshFormat.MESH_FORMAT_PLY;</span>
    }

    /**
     * Reads the header of provided file and determines whether file is valid or
     * not.
     *
     * @return True if file is a valid PLY file, false otherwise.
     * @throws LockedException Raised if this instance is locked because loading
     *                         is in progress.
     * @throws IOException     if an i/O error occurs.
     */
    @Override
    public boolean isValidFile() throws LockedException, IOException {
<span class="fc bfc" id="L631" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L632">            throw new LockedException();</span>
        }

<span class="fc" id="L635">        setLocked(true);</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        if (reader == null) {</span>
<span class="fc" id="L637">            throw new IOException();</span>
        }
        try {
<span class="fc" id="L640">            readHeader();</span>
<span class="nc" id="L641">        } catch (final LoaderException ex) {</span>
<span class="nc" id="L642">            validStream = false;</span>
<span class="fc" id="L643">        }</span>
<span class="fc" id="L644">        setLocked(false);</span>
<span class="fc" id="L645">        return validStream;</span>
    }

    /**
     * Starts the loading process.
     * This method reads the file header, checks its validity and prepares an
     * iterator so the loading process can be carried in an iterative process.
     *
     * @return Iterator to load the file in small chunks of data.
     * @throws LockedException   Raised if this instance is locked because loading
     *                           is in progress.
     * @throws NotReadyException raised if this instance is not yet ready
     *                           because not enough parameters have been set.
     * @throws IOException       if an I/O error occurs.
     * @throws LoaderException   Raised if file is not a valid PLY or is corrupted.
     */
    @Override
    public LoaderIterator load() throws LockedException, NotReadyException, IOException, LoaderException {
<span class="fc bfc" id="L663" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L664">            throw new NotReadyException();</span>
        }

<span class="fc" id="L667">        readFromStream();</span>
<span class="fc" id="L668">        return loaderIterator;</span>
    }

    /**
     * Internal method to set maximum number of vertices to keep in a chunk of
     * data.
     *
     * @param maxVerticesInChunk Indicates maximum number of vertices to keep in
     *                           a chunk of data.
     * @throws IllegalArgumentException Raised if maximum number of vertices is
     *                                  smaller than MIN_MAX_VERTICES_IN_CHUNK.
     */
    private void internalSetMaxVerticesInChunk(final int maxVerticesInChunk) {
<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (maxVerticesInChunk &lt; MIN_MAX_VERTICES_IN_CHUNK) {</span>
<span class="fc" id="L682">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L685">        this.maxVerticesInChunk = maxVerticesInChunk;</span>
<span class="fc" id="L686">    }</span>

    /**
     * Internal method to set whether duplicate vertices in a chunk are allowed.
     * By allowing duplicate vertices, PLY loading can be speed up a little bit
     * at the expense of getting larger sets of data which will contain
     * redundant vertices. If your environment is memory constrained, this
     * should be disabled. By default, it is disabled.
     *
     * @param allow Indicates whether duplicates will be allowed or not.
     */
    private void internalSetAllowDuplicateVerticesInChunk(final boolean allow) {
<span class="fc" id="L698">        allowDuplicateVerticesInChunk = allow;</span>
<span class="fc" id="L699">    }</span>

    /**
     * Internal method to set maximum number of stream positions to be cached.
     * This loader keeps track of a set of stream positions that have been
     * parsed on ASCII mode. By keeping a cache of positions loading times can
     * be largely reduced at the expense of using more memory during loading.
     * By default, this is set to 1000000 positions.
     * This only has effect on ASCII PLY files. For binary PLY files this
     * setting is ignored.
     *
     * @param maxStreamPositions Maximum number of stream positions to be cached.
     * @throws IllegalArgumentException Raised if provided value is lower than
     *                                  DEFAULT_MAX_STREAM_POSITIONS.
     */
    private void internalSetMaxStreamPositions(final long maxStreamPositions) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">        if (maxStreamPositions &lt; MIN_STREAM_POSITIONS) {</span>
<span class="fc" id="L716">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L719">        this.maxStreamPositions = maxStreamPositions;</span>
<span class="fc" id="L720">    }</span>

    /**
     * Reads header of provided file and initializes iterator to read data
     * chunks of this file.
     *
     * @throws LockedException Raised if this instance is locked because loading
     *                         is in progress.
     * @throws IOException     if an i/O error occurs.
     * @throws LoaderException Raised if file is not a valid PLY or is corrupted
     */
    private void readFromStream() throws LockedException, IOException, LoaderException {

<span class="fc bfc" id="L733" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L734">            throw new LockedException();</span>
        }

<span class="fc" id="L737">        setLocked(true);</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L739">            listener.onLoadStart(this);</span>
        }

<span class="pc bpc" id="L742" title="1 of 2 branches missed.">        if (reader == null) {</span>
<span class="nc" id="L743">            throw new IOException();</span>
        }

<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if (!validityChecked) {</span>
<span class="fc" id="L747">            readHeader();</span>
        }
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">        if (!validStream) {</span>
<span class="nc" id="L750">            setLocked(false);</span>
<span class="nc" id="L751">            throw new LoaderException();</span>
        }

<span class="fc" id="L754">        loaderIterator = new LoaderIteratorPLY(this);</span>
<span class="fc" id="L755">        loaderIterator.setListener(new LoaderIteratorListenerImpl(this));</span>
<span class="fc" id="L756">    }</span>

    /**
     * Reads the header of provided file.
     *
     * @throws IOException     if an I/O error occurs.
     * @throws LoaderException Raised if file is not a valid PLY or is
     *                         corrupted.
     */
    private void readHeader() throws IOException, LoaderException {
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">        if (reader == null) {</span>
<span class="nc" id="L767">            throw new IOException();</span>
        }

<span class="fc" id="L770">        validityChecked = true;</span>

        // first line must be equal to string &quot;ply&quot;
<span class="fc" id="L773">        var str = reader.readLine();</span>

<span class="pc bpc" id="L775" title="2 of 4 branches missed.">        if (!&quot;ply&quot;.equals(str) || reader.isEndOfStream()) {</span>
<span class="nc" id="L776">            validStream = false;</span>
<span class="nc" id="L777">            throw new LoaderException();</span>
        }

        // second line contains format (i.e: format ascii 1.0)
        // must start with &quot;format&quot; word
        do {
            // loop is to avoid empty strings
            // (because of duplicate spaces or carriage returns)
<span class="fc" id="L785">            str = reader.readWord();</span>
<span class="pc bpc" id="L786" title="3 of 4 branches missed.">        } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L788" title="2 of 4 branches missed.">        if (!&quot;format&quot;.equals(str) || reader.isEndOfStream()) {</span>
<span class="nc" id="L789">            validStream = false;</span>
<span class="nc" id="L790">            throw new LoaderException();</span>
        }

        // next to format word comes storage mode
        do {
            // loop to avoid empty strings
<span class="fc" id="L796">            str = reader.readWord();</span>
<span class="pc bpc" id="L797" title="3 of 4 branches missed.">        } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L799" title="1 of 2 branches missed.">        if (reader.isEndOfStream()) {</span>
<span class="nc" id="L800">            validStream = false;</span>
<span class="nc" id="L801">            throw new LoaderException();</span>
        }

<span class="pc bpc" id="L804" title="1 of 4 branches missed.">        final PLYStorageMode storageMode = switch (str) {</span>
            case &quot;ascii&quot; -&gt;
                // ASCII storage mode
<span class="fc" id="L807">                    PLYStorageMode.PLY_ASCII;</span>
            case &quot;binary_big_endian&quot; -&gt;
                // Binary big endian storage mode
<span class="fc" id="L810">                    PLYStorageMode.PLY_BIG_ENDIAN;</span>
            case &quot;binary_little_endian&quot; -&gt;
                // Binary little endian storage mode
<span class="fc" id="L813">                    PLYStorageMode.PLY_LITTLE_ENDIAN;</span>
            default -&gt; {
                // non supported storage mode
<span class="nc" id="L816">                validStream = false;</span>
<span class="pc" id="L817">                throw new LoaderException();</span>
            }
        };

        // next comes version (always must be 1.0)
        do {
            // loop to avoid empty strings
<span class="fc" id="L824">            str = reader.readWord();</span>
<span class="pc bpc" id="L825" title="3 of 4 branches missed.">        } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L827" title="2 of 4 branches missed.">        if (!&quot;1.0&quot;.equals(str) || reader.isEndOfStream()) {</span>
<span class="nc" id="L828">            validStream = false;</span>
<span class="nc" id="L829">            throw new LoaderException();</span>
        }

        // instantiate header member
<span class="fc" id="L833">        header = new HeaderPLY();</span>
        // set storage mode
<span class="fc" id="L835">        header.setStorageMode(storageMode);</span>

        // read until we find the line end_header
<span class="fc" id="L838">        var endOfHeader = false;</span>
<span class="fc" id="L839">        ElementPLY lastElement = null;</span>
        PropertyPLY property;
        do {
            do {
                // loop to avoid empty strings
<span class="fc" id="L844">                str = reader.readWord();</span>
<span class="pc bpc" id="L845" title="3 of 4 branches missed.">            } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="fc bfc" id="L847" title="All 2 branches covered.">            if (&quot;comment&quot;.equals(str)) {</span>
                // if word is &quot;comment&quot;, read until end of line
<span class="fc" id="L849">                str = reader.readLine();</span>
                // add comment to list of comments in header
<span class="fc" id="L851">                header.getComments().add(str);</span>
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">            } else if (&quot;obj_info&quot;.equals(str)) {</span>
                // if word is &quot;obj_info&quot;, read until end of line
<span class="nc" id="L854">                str = reader.readLine();</span>
                // add obj_info to list of obj_infos in header
<span class="nc" id="L856">                header.getObjInfos().add(str);</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">            } else if (str.endsWith(&quot;element&quot;)) {</span>
                // and element has been found. We read its information and
                // add it to the list of elements

                // next word contains element name
                do {
                    // loop to avoid empty strings
<span class="fc" id="L864">                    str = reader.readWord();</span>
<span class="pc bpc" id="L865" title="3 of 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L867" title="1 of 2 branches missed.">                if (reader.isEndOfStream()) {</span>
<span class="nc" id="L868">                    validStream = false;</span>
<span class="nc" id="L869">                    throw new LoaderException();</span>
                }

<span class="fc" id="L872">                final var elementName = str;</span>

                // next word contains number of instances of this element
                do {
<span class="fc" id="L876">                    str = reader.readWord();</span>
<span class="pc bpc" id="L877" title="3 of 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L879" title="1 of 2 branches missed.">                if (reader.isEndOfStream()) {</span>
<span class="nc" id="L880">                    validStream = false;</span>
<span class="nc" id="L881">                    throw new LoaderException();</span>
                }

                final long elementInstances;
                try {
<span class="fc" id="L886">                    elementInstances = Long.parseLong(str);</span>
<span class="nc" id="L887">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L888">                    throw new IOException(e);</span>
<span class="fc" id="L889">                }</span>

                // instantiate element
<span class="fc" id="L892">                lastElement = new ElementPLY(elementName, elementInstances);</span>

                // add element to header
<span class="fc" id="L895">                header.getElements().add(lastElement);</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">            } else if (&quot;property&quot;.equals(str)) {</span>
                // a property for last element that has been found. We read its
                // information and add it to the element

<span class="pc bpc" id="L900" title="1 of 2 branches missed.">                if (lastElement == null) {</span>
                    // no previous element was defined
<span class="nc" id="L902">                    validStream = false;</span>
<span class="nc" id="L903">                    throw new LoaderException();</span>
                }

                // read next word
                do {
                    // loop to avoid empty strings
<span class="fc" id="L909">                    str = reader.readWord();</span>
<span class="pc bpc" id="L910" title="3 of 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L912" title="1 of 2 branches missed.">                if (reader.isEndOfStream()) {</span>
<span class="nc" id="L913">                    validStream = false;</span>
<span class="nc" id="L914">                    throw new LoaderException();</span>
                }

<span class="fc bfc" id="L917" title="All 2 branches covered.">                if (&quot;list&quot;.equals(str)) {</span>
                    // property is a list
                    final DataTypePLY lengthDataType;
                    final DataTypePLY valueDataType;
                    try {
                        // read length data type
                        do {
                            // loop to avoid empty strings
<span class="fc" id="L925">                            str = reader.readWord();</span>
<span class="pc bpc" id="L926" title="3 of 4 branches missed.">                        } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L928" title="1 of 2 branches missed.">                        if (reader.isEndOfStream()) {</span>
<span class="nc" id="L929">                            validStream = false;</span>
<span class="nc" id="L930">                            throw new LoaderException();</span>
                        }

<span class="fc" id="L933">                        lengthDataType = wordToDataType(str);</span>

                        // read value data type
                        do {
<span class="fc" id="L937">                            str = reader.readWord();</span>
<span class="pc bpc" id="L938" title="3 of 4 branches missed.">                        } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L940" title="1 of 2 branches missed.">                        if (reader.isEndOfStream()) {</span>
<span class="nc" id="L941">                            validStream = false;</span>
<span class="nc" id="L942">                            throw new LoaderException();</span>
                        }

<span class="fc" id="L945">                        valueDataType = wordToDataType(str);</span>
<span class="nc" id="L946">                    } catch (final LoaderException ex) {</span>
                        // some error was found
<span class="nc" id="L948">                        validStream = false;</span>
<span class="nc" id="L949">                        throw ex;</span>
<span class="fc" id="L950">                    }</span>

                    // read property name
                    do {
<span class="fc" id="L954">                        str = reader.readWord();</span>
<span class="pc bpc" id="L955" title="3 of 4 branches missed.">                    } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L957" title="1 of 2 branches missed.">                    if (reader.isEndOfStream()) {</span>
<span class="nc" id="L958">                        validStream = false;</span>
<span class="nc" id="L959">                        throw new LoaderException();</span>
                    }

<span class="fc" id="L962">                    final var propertyName = str;</span>

<span class="fc" id="L964">                    property = new PropertyPLY(propertyName, lengthDataType, valueDataType);</span>
<span class="fc" id="L965">                } else {</span>
                    // property is scalar
                    // word that we have already read should contain value data
                    // type

                    final DataTypePLY valueDataType;
                    try {
<span class="fc" id="L972">                        valueDataType = wordToDataType(str);</span>
<span class="nc" id="L973">                    } catch (final LoaderException ex) {</span>
                        // invalid data type was found
<span class="nc" id="L975">                        validStream = false;</span>
<span class="nc" id="L976">                        throw ex;</span>
<span class="fc" id="L977">                    }</span>
                    // read property name
                    do {
<span class="fc" id="L980">                        str = reader.readWord();</span>
<span class="pc bpc" id="L981" title="3 of 4 branches missed.">                    } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

<span class="pc bpc" id="L983" title="1 of 2 branches missed.">                    if (reader.isEndOfStream()) {</span>
<span class="nc" id="L984">                        validStream = false;</span>
<span class="nc" id="L985">                        throw new LoaderException();</span>
                    }

<span class="fc" id="L988">                    final var propertyName = str;</span>

<span class="fc" id="L990">                    property = new PropertyPLY(propertyName, valueDataType);</span>
                }
                try {
                    // add property to last element
<span class="fc" id="L994">                    lastElement.getProperties().add(property);</span>
<span class="nc" id="L995">                } catch (final NotAvailableException ex) {</span>
<span class="nc" id="L996">                    validStream = false;</span>
<span class="nc" id="L997">                    throw new LoaderException(ex);</span>
<span class="fc" id="L998">                }</span>
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">            } else if (&quot;end_header&quot;.equals(str)) {</span>
                // end of header has been found
<span class="fc" id="L1001">                endOfHeader = true;</span>
            } else {
                // something else that cannot be understood
<span class="nc" id="L1004">                validStream = false;</span>
<span class="nc" id="L1005">                throw new LoaderException();</span>
            }
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        } while (!endOfHeader);</span>

<span class="fc" id="L1009">        validStream = true;</span>
<span class="fc" id="L1010">    }</span>

    /**
     * Converts a word into a data type. If an unsupported word is found then a
     * LoaderException is raised.
     *
     * @param word word to be converted.
     * @return DataType obtained from word.
     * @throws LoaderException Raised if file is not a valid PLY or is
     *                         corrupted (i.e. an unsupported word is found).
     */
    private DataTypePLY wordToDataType(final String word) throws LoaderException {
<span class="fc" id="L1022">        final var dataType = DataTypePLY.forValue(word);</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">        if (dataType == null) {</span>
<span class="nc" id="L1024">            throw new LoaderException();</span>
        }
<span class="fc" id="L1026">        return dataType;</span>
    }

    /**
     * Internal listener to be notified when loading process finishes.
     * This listener is used to free resources when loading process finishes.
     */
    private class LoaderIteratorListenerImpl implements LoaderIteratorListener {

        /**
         * Reference to Loader loading PLY file.
         */
        private final LoaderPLY loader;

        /**
         * Constructor.
         *
         * @param loader reference to Loader.
         */
<span class="fc" id="L1045">        public LoaderIteratorListenerImpl(final LoaderPLY loader) {</span>
<span class="fc" id="L1046">            this.loader = loader;</span>
<span class="fc" id="L1047">        }</span>

        /**
         * Called when a loader iterator has no more data to be read.
         *
         * @param iterator Iterator loading a file.
         */
        @Override
        public void onIteratorFinished(final LoaderIterator iterator) {
            // because iterator is finished, we should allow subsequent calls to
            // load method
            try {
<span class="fc" id="L1059">                reader.seek(0); // attempt restart stream to current position</span>
<span class="nc" id="L1060">            } catch (final Exception ignore) {</span>
                // operation is attempted, if it fails it is ignored
<span class="fc" id="L1062">            }</span>

            // on subsequent calls
<span class="fc" id="L1065">            validityChecked = false; // reset in case we want to read more data</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L1067">                listener.onLoadEnd(loader);</span>
            }
<span class="fc" id="L1069">            setLocked(false);</span>
<span class="fc" id="L1070">        }</span>
    }

    /**
     * Internal implementation of a loader iterator for PLY files.
     */
    private class LoaderIteratorPLY implements LoaderIterator {

        /**
         * Reference to a LoaderPLY.
         */
        private final LoaderPLY loader;

        /**
         * Number of elements in a list property.
         */
        private int listElems;

        /**
         * Last x vertex coordinate that was read.
         */
        private float coordX;

        /**
         * Last y vertex coordinate that was read.
         */
        private float coordY;

        /**
         * Last z vertex coordinate that was read.
         */
        private float coordZ;

        /**
         * Last red color component that was read.
         */
        private short red;

        /**
         * Last green color component that was read.
         */
        private short green;

        /**
         * Last blue color component that was read.
         */
        private short blue;

        /**
         * Last alpha color component that was read.
         */
        private short alpha;

        /**
         * Last normal x component that was red.
         */
        private float nX;

        /**
         * Last normal y component that was read.
         */
        private float nY;

        /**
         * Last normal z component that was read.
         */
        private float nZ;

        /**
         * Last vertex index that was read.
         */
        private long index;

        // coordinates for bounding box in a chunk

        /**
         * Minimum x coordinate of all vertices that have been read so far in
         * current chunk of data.
         */
        private float minX;

        /**
         * Minimum y coordinate of all vertices that have been read so far in
         * current chunk of data.
         */
        private float minY;

        /**
         * Minimum z coordinate of all vertices that have been read so far in
         * current chunk of data.
         */
        private float minZ;

        /**
         * Maximum x coordinate of all vertices that have been read so far in
         * current chunk of data.
         */
        private float maxX;

        /**
         * Maximum y coordinate of all vertices that have been read so far in
         * current chunk of data.
         */
        private float maxY;

        /**
         * Maximum z coordinate of all vertices that have been read so far in
         * current chunk of data.
         */
        private float maxZ;

        /**
         * Indicates whether file contains vertices.
         */
        private boolean verticesAvailable;

        /**
         * Indicates whether file contains colors.
         */
        private boolean colorsAvailable;

        /**
         * Indicates whether file contains vertex indices.
         */
        private boolean indicesAvailable;

        /**
         * Indicates whether file contains normals.
         */
        private boolean normalsAvailable;

        /**
         * Indicates number of color components of vertices.
         */
        private int colorComponents;

        /**
         * Stores position where header of file finishes.
         */
        private long endHeaderStreamPosition;

        /**
         * Number of vertices contained in the file.
         */
        private long numberOfVertices;

        /**
         * Number of faces (triangles or polygons) contained in the file.
         */
        private long numberOfFaces;

        /**
         * Stores position where first vertex is located.
         */
        private long firstVertexStreamPosition;

        /**
         * Indicates whether first vertex position has already been read and is
         * available.
         */
        private boolean firstVertexStreamPositionAvailable;

        /**
         * Indicates size of vertex data.
         */
        private long vertexDataSize;

        /**
         * Stores position where first vertex index containing a triangle or
         * polygon is located.
         */
        private long firstFaceStreamPosition;

        /**
         * Indicates whether first vertex index position has already been read
         * and is available.
         */
        private boolean firstFaceStreamPositionAvailable;

        /**
         * Stores current position in file stream.
         */
        private long currentStreamPosition;

        /**
         * Number of instances of a given element in the header of the file
         * (i.e. number of vertices or faces).
         */
        private long totalInstances;

        /**
         * A header element that contains vertex properties.
         */
        private ElementPLY vertexElement;

        /**
         * A header element that contains face (triangles/polygons) properties.
         */
        private ElementPLY faceElement;

        /**
         * Current triangle/polygon being read from all faces available in the
         * file.
         */
        private long currentFace;

        /**
         * Listener to fetch a vertex position in the stream of data based on
         * its vertex index.
         * There are implementations for binary and text (ascii) fetchers.
         */
        private VertexFetcherListener fetchVertexListener;

        /**
         * Listener of this iterator that notifies the loader when the iterator
         * has finished loading the file, so that the loader becomes unlocked
         * again.
         */
        private LoaderIteratorListener listener;

        /**
         * Array containing vertex coordinates in current chunk of data.
         * Data is stored sequentially as x1, y1, z1, x2, y2, z2, etc.
         */
        private float[] coordsInChunkArray;

        /**
         * Array containing vertex colors in current chunk of data.
         * Data is stored sequentially depending on the number of color
         * components. For instance, for RGB this would be: r1, g1, b1, r2, g2,
         * b2, etc.
         */
        private short[] colorsInChunkArray;

        /**
         * Indices of vertices in current chunk.
         * Indices are stored sequentially in sets of 3 forming triangles like
         * this: t1a, t1b, t1c, t2a, t2b, t2c, etc.
         */
        private int[] indicesInChunkArray;

        /**
         * Indices of vertices in file. Original indices might differ of indices
         * numeration in current chunk because for each chunk indices start
         * again at zero. Indices are stored sequentially in sets of 3
         * forming triangles like: t1a, t1b, t1c, t2a, t2b, t2c, etc.
         */
        private long[] originalIndicesInChunkArray;

        /**
         * Normals of vertices in current chunk.
         * Normals are stored sequentially for each vertex like this: n1x, n1y,
         * n1z, n2x, n2y, n2z, etc.
         */
        private float[] normalsInChunkArray;

        /**
         * Number of vertices currently stored in chunk.
         * This is used to determine when no more vertices can be stored in
         * a chunk and an additional chunk needs to be loaded.
         */
        private int verticesInChunk;

        /**
         * Number of indices currently stored in chunk.
         */
        private int indicesInChunk;

        /**
         * Number of indices used as a default to initialize arrays.
         * When the number of indices exceeds this value arrays will be resized.
         */
        private int indicesInChunkSize;

        /**
         * Stores current stream position so that vertices positions can be
         * cached.
         */
        private long vertexStreamPosition;

        /**
         * Map containing relations between original indices of the stream (key)
         * and their corresponding index in the chunk (value).
         */
        private final TreeMap&lt;Long, Integer&gt; indicesMap;

        /**
         * Map relating original indices in stream (key) and stream positions
         * (value).
         */
        private final TreeMap&lt;Long, Long&gt; verticesStreamPositionsMap;

        /**
         * Constructor.
         *
         * @param loader Reference to the loader controlling this iterator.
         * @throws LoaderException Raised if file is corrupted and cannot be
         *                         loaded.
         * @throws IOException     if an I/O error occurs.
         */
<span class="fc" id="L1370">        public LoaderIteratorPLY(final LoaderPLY loader) throws LoaderException, IOException {</span>
<span class="fc" id="L1371">            this.loader = loader;</span>
<span class="fc" id="L1372">            listElems = 1;</span>
<span class="fc" id="L1373">            nX = nY = nZ = 1.0f;</span>
<span class="fc" id="L1374">            alpha = 255;</span>
<span class="fc" id="L1375">            index = 0;</span>
<span class="fc" id="L1376">            colorComponents = 0;</span>
<span class="fc" id="L1377">            verticesAvailable = colorsAvailable = indicesAvailable = normalsAvailable = false;</span>
<span class="fc" id="L1378">            endHeaderStreamPosition = numberOfVertices = numberOfFaces = 0;</span>
<span class="fc" id="L1379">            firstVertexStreamPosition = 0;</span>
<span class="fc" id="L1380">            firstVertexStreamPositionAvailable = false;</span>
<span class="fc" id="L1381">            vertexDataSize = 0;</span>
<span class="fc" id="L1382">            firstFaceStreamPositionAvailable = false;</span>
<span class="fc" id="L1383">            currentStreamPosition = 0;</span>
<span class="fc" id="L1384">            totalInstances = 0;</span>
<span class="fc" id="L1385">            vertexElement = faceElement = null;</span>
<span class="fc" id="L1386">            currentFace = 0;</span>
<span class="fc" id="L1387">            fetchVertexListener = null;</span>
<span class="fc" id="L1388">            listener = null;</span>
<span class="fc" id="L1389">            coordsInChunkArray = null;</span>
<span class="fc" id="L1390">            colorsInChunkArray = null;</span>
<span class="fc" id="L1391">            indicesInChunkArray = null;</span>
<span class="fc" id="L1392">            originalIndicesInChunkArray = null;</span>
<span class="fc" id="L1393">            normalsInChunkArray = null;</span>
<span class="fc" id="L1394">            verticesInChunk = indicesInChunk = 0;</span>
<span class="fc" id="L1395">            indicesInChunkSize = 0;</span>
<span class="fc" id="L1396">            vertexStreamPosition = 0;</span>
<span class="fc" id="L1397">            indicesMap = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L1398">            verticesStreamPositionsMap = new TreeMap&lt;&gt;();</span>

<span class="fc" id="L1400">            minX = minY = minZ = Float.MAX_VALUE;</span>
<span class="fc" id="L1401">            maxX = maxY = maxZ = -Float.MAX_VALUE;</span>

<span class="fc" id="L1403">            setUp();</span>
<span class="fc" id="L1404">        }</span>

        /**
         * Sets listener to notify when this iterator has finished loading the
         * PLY file.
         *
         * @param listener listener to notify when this iterator has finished
         *                 loading the PLY file.
         */
        public void setListener(final LoaderIteratorListener listener) {
<span class="fc" id="L1414">            this.listener = listener;</span>
<span class="fc" id="L1415">        }</span>

        /**
         * Indicates if there are still more chunks of data to be read on this
         * PLY file.
         *
         * @return True if there are more chunks of data, false otherwise.
         */
        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L1425" title="All 2 branches covered.">            return (currentFace &lt; numberOfFaces);</span>
        }

        /**
         * Reads next chunk of data from PLY file.
         *
         * @return A chunk of data containing vertex coordinates, colors, vertex
         * normals, textures, etc.
         * @throws NotAvailableException Raised if no more chunks are available.
         * @throws LoaderException       Raised if file is corrupted and cannot be
         *                               loaded.
         * @throws IOException           Raised if an I/O error occurs.
         */
        @Override
        @SuppressWarnings(&quot;all&quot;)
        public DataChunk next() throws NotAvailableException, LoaderException, IOException {

<span class="pc bpc" id="L1442" title="1 of 2 branches missed.">            if (reader == null) {</span>
<span class="nc" id="L1443">                throw new IOException();</span>
            }

<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">            if (!hasNext()) {</span>
<span class="nc" id="L1447">                throw new NotAvailableException();</span>
            }

<span class="fc" id="L1450">            initChunkArrays();</span>

            // reset chunk bounding box values
<span class="fc" id="L1453">            minX = minY = minZ = Float.MAX_VALUE;</span>
<span class="fc" id="L1454">            maxX = maxY = maxZ = -Float.MAX_VALUE;</span>

<span class="fc" id="L1456">            final var buffer = ByteBuffer.allocate(BUFFER_SIZE);</span>

<span class="fc" id="L1458">            final var nElems = faceElement.getNumberOfInstances();</span>
<span class="fc" id="L1459">            final var progressStep = Math.max((long) (LoaderPLY.PROGRESS_DELTA * nElems), 1);</span>

<span class="fc" id="L1461">            var end = false;</span>

            // initialize list indices to a list of one element to be reused
<span class="fc" id="L1464">            var previousListElems = 1;</span>
<span class="fc" id="L1465">            var listIndices = new long[previousListElems];</span>

<span class="fc bfc" id="L1467" title="All 4 branches covered.">            while ((currentFace &lt; nElems) &amp;&amp; !end) {</span>

<span class="fc" id="L1469">                final var faceStreamPos = reader.getPosition();</span>
                // Iterate on properties
<span class="fc bfc" id="L1471" title="All 2 branches covered.">                for (final var property : faceElement.getProperties()) {</span>
<span class="pc bpc" id="L1472" title="1 of 2 branches missed.">                    if (!property.isValidProperty()) {</span>
<span class="nc" id="L1473">                        throw new LoaderException();</span>
                    }

                    // number of elements in list (initially assume that is
                    // scalar, hence 1)
<span class="fc" id="L1478">                    listElems = 1;</span>

                    // set listeners to read property length value
<span class="fc" id="L1481">                    PLYReadValueFromStreamListener readValueFromStreamListener =</span>
<span class="fc" id="L1482">                            property.getReadLengthValueFromStreamListener();</span>
<span class="fc" id="L1483">                    PLYReadValueFromBufferListener readValueFromBufferListener =</span>
<span class="fc" id="L1484">                            property.getReadLengthValueFromBufferListener();</span>

<span class="pc bpc" id="L1486" title="1 of 2 branches missed.">                    if (property.getPropertyType() == PropertyTypePLY.PROPERTY_PLY_LIST) {</span>
                        // read number of list elements
<span class="fc" id="L1488">                        readValueFromStreamListener.readFromStream(buffer);</span>

<span class="pc bpc" id="L1490" title="3 of 4 branches missed.">                        if (reader.isEndOfStream() &amp;&amp; (currentFace &lt; (nElems - 1))) {</span>
<span class="nc" id="L1491">                            throw new LoaderException();</span>
                        }

                        // set listElems
<span class="fc" id="L1495">                        readValueFromBufferListener.readValueFromBuffer(buffer);</span>
                    }

<span class="fc" id="L1498">                    var needsTriangulation = false;</span>
<span class="pc bpc" id="L1499" title="1 of 2 branches missed.">                    if (listElems &gt; 3) {</span>
<span class="nc" id="L1500">                        needsTriangulation = true;</span>
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">                    } else if (listElems &lt; 3) {</span>
                        // list does not form a triangle or polygon
<span class="nc" id="L1503">                        throw new LoaderException();</span>
                    }

<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">                    if (listElems &gt; loader.maxVerticesInChunk) {</span>
                        // this list will never fit in a chunk with current
                        // maxVerticesInChunk setting
<span class="nc" id="L1509">                        throw new LoaderException();</span>
                    }

<span class="fc bfc" id="L1512" title="All 2 branches covered.">                    if ((verticesInChunk + listElems) &gt; loader.maxVerticesInChunk) {</span>
                        // no more vertices can be added to chunk so we reset stream
                        // to start on current face
<span class="fc" id="L1515">                        reader.seek(faceStreamPos);</span>
<span class="fc" id="L1516">                        end = true;</span>
<span class="fc" id="L1517">                        break;</span>
                    }

                    // set listeners to read property value
<span class="fc" id="L1521">                    readValueFromStreamListener = property.getReadValueFromStreamListener();</span>
<span class="fc" id="L1522">                    readValueFromBufferListener = property.getReadValueFromBufferListener();</span>

<span class="fc bfc" id="L1524" title="All 2 branches covered.">                    if (previousListElems != listElems) {</span>
                        // listIndices can no longer be reused
<span class="fc" id="L1526">                        listIndices = new long[listElems];</span>
                    }

                    // read property list data
<span class="fc bfc" id="L1530" title="All 2 branches covered.">                    for (var u = 0; u &lt; listElems; u++) {</span>
                        // reads face index from stream and saves it into buffer
<span class="fc" id="L1532">                        readValueFromStreamListener.readFromStream(buffer);</span>

<span class="pc bpc" id="L1534" title="1 of 4 branches missed.">                        if (reader.isEndOfStream() &amp;&amp; (currentFace &lt; (nElems - 1))) {</span>
<span class="nc" id="L1535">                            throw new LoaderException();</span>
                        }

                        // copies buffer content into index member doing proper
                        // type conversion
<span class="fc" id="L1540">                        readValueFromBufferListener.readValueFromBuffer(buffer);</span>

<span class="fc" id="L1542">                        listIndices[u] = index;</span>
                    }

                    // keep current face stream position
<span class="fc" id="L1546">                    currentStreamPosition = reader.getPosition();</span>

<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">                    if (needsTriangulation) {</span>
                        // search vertices data corresponding to read indices
<span class="nc" id="L1550">                        final var polygonVertices = new ArrayList&lt;Point3D&gt;(listElems);</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                        for (var u = 0; u &lt; listElems; u++) {</span>
<span class="nc" id="L1552">                            index = listIndices[u];</span>
                            // vertex needs to be added into chunk, so we need to
                            // read vertex data

                            // fetch vertex data position
<span class="nc" id="L1557">                            fetchVertexListener.fetch(index);</span>

                            // read all vertex data
<span class="nc bnc" id="L1560" title="All 2 branches missed.">                            for (final var vertexProperty : vertexElement.getProperties()) {</span>

                                // set delegates to read property value from stream
<span class="nc" id="L1563">                                readValueFromStreamListener = vertexProperty.getReadValueFromStreamListener();</span>

                                // read property from stream to buffer
<span class="nc" id="L1566">                                readValueFromStreamListener.readFromStream(buffer);</span>

<span class="nc bnc" id="L1568" title="All 2 branches missed.">                                if (vertexProperty.isReadValueFromBufferListenerAvailable()) {</span>
                                    // only read from buffer if property is recognized by this class
<span class="nc" id="L1570">                                    readValueFromBufferListener = vertexProperty.getReadValueFromBufferListener();</span>

                                    // move value from buffer to apropriate member
<span class="nc" id="L1573">                                    readValueFromBufferListener.readValueFromBuffer(buffer);</span>
                                }
<span class="nc" id="L1575">                            }</span>

<span class="nc" id="L1577">                            final var point = new InhomogeneousPoint3D(coordX, coordY, coordZ);</span>
<span class="nc" id="L1578">                            polygonVertices.add(point);</span>
                        }

                        try {
<span class="nc" id="L1582">                            listIndices = buildTriangulatedIndices(polygonVertices, listIndices);</span>
<span class="nc" id="L1583">                            listElems = listIndices.length;</span>
<span class="nc" id="L1584">                        } catch (final TriangulatorException e) {</span>
                            // reset face stream position
<span class="nc" id="L1586">                            reader.seek(currentStreamPosition);</span>
<span class="nc" id="L1587">                            continue;</span>
<span class="nc" id="L1588">                        }</span>
                    }

                    // search for vertices indices contained in list
<span class="fc bfc" id="L1592" title="All 2 branches covered.">                    for (var u = 0; u &lt; listElems; u++) {</span>
<span class="fc" id="L1593">                        index = listIndices[u];</span>
                        // index contains original face index in PLY file
                        int chunkIndex;
<span class="fc bfc" id="L1596" title="All 4 branches covered.">                        if (!loader.allowDuplicateVerticesInChunk &amp;&amp; (chunkIndex = searchIndexInChunk(index)) &gt;= 0) {</span>
                            // vertex is already stored in chunk with chunkIndex
<span class="fc" id="L1598">                            addExistingVertexToChunk(chunkIndex);</span>
                        } else {
                            // vertex needs to be added into chunk, so we need to
                            // read vertex data

                            // fetch vertex data position
<span class="fc" id="L1604">                            fetchVertexListener.fetch(index);</span>

                            // read all vertex data
<span class="fc bfc" id="L1607" title="All 2 branches covered.">                            for (final var vertexProperty : vertexElement.getProperties()) {</span>

                                // set delegates to read property value from stream
<span class="fc" id="L1610">                                readValueFromStreamListener = vertexProperty.getReadValueFromStreamListener();</span>

                                // read property from stream to buffer
<span class="fc" id="L1613">                                readValueFromStreamListener.readFromStream(buffer);</span>

<span class="fc bfc" id="L1615" title="All 2 branches covered.">                                if (vertexProperty.isReadValueFromBufferListenerAvailable()) {</span>
                                    // only read from buffer if property is recognized by this class
<span class="fc" id="L1617">                                    readValueFromBufferListener = vertexProperty.getReadValueFromBufferListener();</span>

                                    // move value from buffer to apropriate member
<span class="fc" id="L1620">                                    readValueFromBufferListener.readValueFromBuffer(buffer);</span>
                                }
<span class="fc" id="L1622">                            }</span>

                            // store all vertex data into chunk arrays
<span class="fc" id="L1625">                            addNewVertexDataToChunk();</span>
                        }
                    }

                    // reset face stream position
<span class="fc" id="L1630">                    reader.seek(currentStreamPosition);</span>

                    // to reduce memory consumption and delete listIndices
<span class="fc bfc" id="L1633" title="All 2 branches covered.">                    if (previousListElems != listElems) {</span>
                        // list indices haven't been reused

                        // update previousListElems
<span class="fc" id="L1637">                        previousListElems = listElems;</span>
                    }
<span class="fc" id="L1639">                }</span>

<span class="fc bfc" id="L1641" title="All 2 branches covered.">                if (!end) {</span>
<span class="fc" id="L1642">                    currentFace++;</span>
                }

                // compute progress
<span class="fc bfc" id="L1646" title="All 2 branches covered.">                if (loader.listener != null) {</span>
<span class="fc bfc" id="L1647" title="All 2 branches covered.">                    if ((currentFace % progressStep) == 0) {</span>
<span class="fc" id="L1648">                        loader.listener.onLoadProgressChange(loader, (float) (currentFace) / (float) (nElems));</span>
                    }
                }
<span class="fc" id="L1651">            }</span>

            // trim arrays to store only needed data
<span class="fc" id="L1654">            trimArrays();</span>

            // Instantiate DataChunk with chunk arrays
<span class="fc" id="L1657">            final var dataChunk = new DataChunk();</span>
<span class="pc bpc" id="L1658" title="1 of 2 branches missed.">            if (verticesAvailable) {</span>
<span class="fc" id="L1659">                dataChunk.setVerticesCoordinatesData(coordsInChunkArray);</span>
<span class="fc" id="L1660">                dataChunk.setMinX(minX);</span>
<span class="fc" id="L1661">                dataChunk.setMinY(minY);</span>
<span class="fc" id="L1662">                dataChunk.setMinZ(minZ);</span>
<span class="fc" id="L1663">                dataChunk.setMaxX(maxX);</span>
<span class="fc" id="L1664">                dataChunk.setMaxY(maxY);</span>
<span class="fc" id="L1665">                dataChunk.setMaxZ(maxZ);</span>
            } else {
                // so it can be garbage collected
<span class="nc" id="L1668">                coordsInChunkArray = null;</span>
            }

<span class="pc bpc" id="L1671" title="1 of 2 branches missed.">            if (colorsAvailable) {</span>
<span class="fc" id="L1672">                dataChunk.setColorData(colorsInChunkArray);</span>
<span class="fc" id="L1673">                dataChunk.setColorComponents(colorComponents);</span>
            } else {
                // so it can be garbage collected
<span class="nc" id="L1676">                colorsInChunkArray = null;</span>
            }

<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">            if (indicesAvailable) {</span>
<span class="fc" id="L1680">                dataChunk.setIndicesData(indicesInChunkArray);</span>
            } else {
                // so it can be garbage collected
<span class="nc" id="L1683">                indicesInChunkArray = null;</span>
            }

<span class="fc bfc" id="L1686" title="All 2 branches covered.">            if (normalsAvailable) {</span>
<span class="fc" id="L1687">                dataChunk.setNormalsData(normalsInChunkArray);</span>
            } else {
                // so it can be garbage collected
<span class="fc" id="L1690">                normalsInChunkArray = null;</span>
            }

<span class="fc bfc" id="L1693" title="All 2 branches covered.">            if (!hasNext()) {</span>
                // notify iterator finished
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">                if (listener != null) {</span>
<span class="fc" id="L1696">                    listener.onIteratorFinished(this);</span>
                }
            }

            // if no more chunks are available, then close input reader
<span class="fc bfc" id="L1701" title="All 2 branches covered.">            if (!hasNext()) {</span>
<span class="fc" id="L1702">                reader.close();</span>
            }

<span class="fc" id="L1705">            return dataChunk;</span>
        }

        /**
         * Triangulates provided polygon having vertices corresponding to
         * provided indices and returns an array of indices corresponding to the
         * triangles forming the polygon.
         *
         * @param polygonVertices vertices forming a polygon to be triangulated.
         * @param plyIndices      indices corresponding to provided polygon.
         * @return array of indices corresponding to the triangles forming the
         * polygon.
         * @throws TriangulatorException if triangulation fails because polygon
         *                               is degenerate or vertices contains invalid values such as NaN or
         *                               infinity.
         */
        private long[] buildTriangulatedIndices(final List&lt;Point3D&gt; polygonVertices, final long[] plyIndices)
                throws TriangulatorException {

<span class="nc" id="L1724">            final var indices = new ArrayList&lt;int[]&gt;();</span>
<span class="nc" id="L1725">            final var triangulator = Triangulator3D.create();</span>
<span class="nc" id="L1726">            final var triangles = triangulator.triangulate(polygonVertices, indices);</span>

<span class="nc" id="L1728">            final var result = new long[triangles.size() * 3];</span>
<span class="nc" id="L1729">            var pos = 0;</span>
            long plyIndex;
<span class="nc bnc" id="L1731" title="All 2 branches missed.">            for (final var triangleIndices : indices) {</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">                for (final var triangleIndex : triangleIndices) {</span>
<span class="nc" id="L1733">                    plyIndex = plyIndices[triangleIndex];</span>
<span class="nc" id="L1734">                    result[pos] = plyIndex;</span>
<span class="nc" id="L1735">                    pos++;</span>
                }
<span class="nc" id="L1737">            }</span>

<span class="nc" id="L1739">            return result;</span>
        }


        /**
         * Initializes arrays where chunk data will be stored.
         */
        private void initChunkArrays() {
<span class="fc" id="L1747">            coordsInChunkArray = new float[loader.maxVerticesInChunk * 3];</span>
<span class="fc" id="L1748">            colorsInChunkArray = new short[loader.maxVerticesInChunk * colorComponents];</span>
<span class="fc" id="L1749">            indicesInChunkArray = new int[loader.maxVerticesInChunk];</span>
<span class="fc" id="L1750">            originalIndicesInChunkArray = new long[loader.maxVerticesInChunk];</span>
<span class="fc" id="L1751">            normalsInChunkArray = new float[loader.maxVerticesInChunk * 3];</span>
<span class="fc" id="L1752">            verticesInChunk = 0;</span>
<span class="fc" id="L1753">            indicesInChunk = 0;</span>
<span class="fc" id="L1754">            indicesInChunkSize = loader.maxVerticesInChunk;</span>
<span class="fc" id="L1755">            indicesMap.clear();</span>
<span class="fc" id="L1756">        }</span>

        /**
         * Searches corresponding index in chunk for provided stream vertex
         * index.
         *
         * @param originalIndex Index in original stream of data.
         * @return Vertex index in current chunk of data.
         */
        private int searchIndexInChunk(final long originalIndex) {
<span class="fc" id="L1766">            final var chunkIndex = indicesMap.get(originalIndex);</span>

<span class="fc bfc" id="L1768" title="All 2 branches covered.">            if (chunkIndex == null) {</span>
<span class="fc" id="L1769">                return -1;</span>
            }

<span class="fc" id="L1772">            return indicesInChunkArray[chunkIndex];</span>
        }

        /**
         * Caches provided vertex index to relate it to given stream position
         * where vertex data can be found.
         * This method only has effect for ASCII PLY files.
         *
         * @param originalIndex  Vertex index in original stream of data.
         * @param streamPosition Stream position where vertex is found.
         */
        private void addVertexPositionToMap(final long originalIndex, final long streamPosition) {
<span class="fc bfc" id="L1784" title="All 2 branches covered.">            if (loader.header.getStorageMode() == PLYStorageMode.PLY_ASCII) {</span>
<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">                if (verticesStreamPositionsMap.size() &gt; loader.maxStreamPositions) {</span>
                    // Map is full. Remove 1st item before adding a new one
<span class="nc" id="L1787">                    final var origIndex = verticesStreamPositionsMap.firstKey();</span>
<span class="nc" id="L1788">                    verticesStreamPositionsMap.remove(origIndex);</span>
                }
                // add new item
<span class="fc" id="L1791">                verticesStreamPositionsMap.put(originalIndex, streamPosition);</span>
            }
<span class="fc" id="L1793">        }</span>

        /**
         * Adds data of last vertex that has been read to the arrays of current
         * chunk of data.
         */
        private void addNewVertexDataToChunk() {
<span class="fc" id="L1800">            var pos = 3 * verticesInChunk;</span>
<span class="fc" id="L1801">            var colorPos = colorComponents * verticesInChunk;</span>
<span class="fc" id="L1802">            coordsInChunkArray[pos] = coordX;</span>
<span class="fc" id="L1803">            normalsInChunkArray[pos] = nX;</span>
<span class="pc bpc" id="L1804" title="1 of 2 branches missed.">            if (colorComponents &gt;= 1) {</span>
<span class="fc" id="L1805">                colorsInChunkArray[colorPos] = red;</span>
            }

<span class="fc" id="L1808">            pos++;</span>
<span class="fc" id="L1809">            colorPos++;</span>

<span class="fc" id="L1811">            coordsInChunkArray[pos] = coordY;</span>
<span class="fc" id="L1812">            normalsInChunkArray[pos] = nY;</span>
<span class="pc bpc" id="L1813" title="1 of 2 branches missed.">            if (colorComponents &gt;= 2) {</span>
<span class="fc" id="L1814">                colorsInChunkArray[colorPos] = green;</span>
            }

<span class="fc" id="L1817">            pos++;</span>
<span class="fc" id="L1818">            colorPos++;</span>

<span class="fc" id="L1820">            coordsInChunkArray[pos] = coordZ;</span>
<span class="fc" id="L1821">            normalsInChunkArray[pos] = nZ;</span>
<span class="pc bpc" id="L1822" title="1 of 2 branches missed.">            if (colorComponents &gt;= 3) {</span>
<span class="fc" id="L1823">                colorsInChunkArray[colorPos] = blue;</span>
            }

<span class="fc bfc" id="L1826" title="All 2 branches covered.">            if (colorComponents &gt;= 4) {</span>
<span class="fc" id="L1827">                colorPos++;</span>
<span class="fc" id="L1828">                colorsInChunkArray[colorPos] = alpha;</span>
            }

            // update bounding box values
<span class="fc bfc" id="L1832" title="All 2 branches covered.">            if (coordX &lt; minX) {</span>
<span class="fc" id="L1833">                minX = coordX;</span>
            }
<span class="fc bfc" id="L1835" title="All 2 branches covered.">            if (coordY &lt; minY) {</span>
<span class="fc" id="L1836">                minY = coordY;</span>
            }
<span class="fc bfc" id="L1838" title="All 2 branches covered.">            if (coordZ &lt; minZ) {</span>
<span class="fc" id="L1839">                minZ = coordZ;</span>
            }

<span class="fc bfc" id="L1842" title="All 2 branches covered.">            if (coordX &gt; maxX) {</span>
<span class="fc" id="L1843">                maxX = coordX;</span>
            }
<span class="fc bfc" id="L1845" title="All 2 branches covered.">            if (coordY &gt; maxY) {</span>
<span class="fc" id="L1846">                maxY = coordY;</span>
            }
<span class="fc bfc" id="L1848" title="All 2 branches covered.">            if (coordZ &gt; maxZ) {</span>
<span class="fc" id="L1849">                maxZ = coordZ;</span>
            }

            // if arrays of indices become full, we need to resize them
<span class="fc bfc" id="L1853" title="All 2 branches covered.">            if (indicesInChunk &gt;= indicesInChunkSize) {</span>
<span class="fc" id="L1854">                increaseIndicesArraySize();</span>
            }
<span class="fc" id="L1856">            indicesInChunkArray[indicesInChunk] = verticesInChunk;</span>
<span class="fc" id="L1857">            originalIndicesInChunkArray[indicesInChunk] = index;</span>
            // store original index in map, so we can search chunk index by
            // original index
<span class="fc" id="L1860">            indicesMap.put(index, indicesInChunk);</span>

            // store vertex stream position in ascii mode
<span class="fc" id="L1863">            addVertexPositionToMap(index, vertexStreamPosition);</span>

<span class="fc" id="L1865">            verticesInChunk++;</span>
<span class="fc" id="L1866">            indicesInChunk++;</span>
<span class="fc" id="L1867">        }</span>

        /**
         * Adds provided vertex index into chunk of data.
         * This method is only called when duplicate vertices are allowed in
         * chunks of data.
         *
         * @param existingIndex Index to be added into chunk.
         */
        private void addExistingVertexToChunk(final int existingIndex) {
            // if arrays of indices become full, we need to resize them
<span class="fc bfc" id="L1878" title="All 2 branches covered.">            if (indicesInChunk &gt;= indicesInChunkSize) {</span>
<span class="fc" id="L1879">                increaseIndicesArraySize();</span>
            }
<span class="fc" id="L1881">            indicesInChunkArray[indicesInChunk] = existingIndex;</span>
<span class="fc" id="L1882">            originalIndicesInChunkArray[indicesInChunk] = index;</span>

<span class="fc" id="L1884">            indicesInChunk++;</span>
<span class="fc" id="L1885">        }</span>

        /**
         * This method increases the size of arrays containing data of current
         * chunk. This method is called when arrays get full and need to be
         * enlarged.
         */
        private void increaseIndicesArraySize() {
<span class="fc" id="L1893">            final var newIndicesInChunkSize = indicesInChunkSize + loader.maxVerticesInChunk;</span>
<span class="fc" id="L1894">            final var newIndicesInChunkArray = new int[newIndicesInChunkSize];</span>
<span class="fc" id="L1895">            final var newOriginalIndicesInChunkArray = new long[newIndicesInChunkSize];</span>

            // copy contents of old arrays
<span class="fc" id="L1898">            System.arraycopy(indicesInChunkArray, 0, newIndicesInChunkArray, 0, indicesInChunkSize);</span>
<span class="fc" id="L1899">            System.arraycopy(originalIndicesInChunkArray, 0, newOriginalIndicesInChunkArray, 0,</span>
                    indicesInChunkSize);

            // set new arrays and new size
<span class="fc" id="L1903">            indicesInChunkArray = newIndicesInChunkArray;</span>
<span class="fc" id="L1904">            originalIndicesInChunkArray = newOriginalIndicesInChunkArray;</span>
<span class="fc" id="L1905">            indicesInChunkSize = newIndicesInChunkSize;</span>
<span class="fc" id="L1906">        }</span>

        /**
         * This method removes unnecessary data of arrays.
         * This method is called when finishing the processing of current chunk
         * of data.
         */
        private void trimArrays() {
<span class="pc bpc" id="L1914" title="1 of 2 branches missed.">            if (verticesInChunk &gt; 0) {</span>
<span class="fc" id="L1915">                final var elems = verticesInChunk * 3;</span>
<span class="fc" id="L1916">                final var colorElems = verticesInChunk * colorComponents;</span>

<span class="fc" id="L1918">                final var newCoordsInChunkArray = new float[elems];</span>
<span class="fc" id="L1919">                final var newColorsInChunkArray = new short[colorElems];</span>
<span class="fc" id="L1920">                final var newNormalsInChunkArray = new float[elems];</span>

                // copy contents of old arrays
<span class="fc" id="L1923">                System.arraycopy(coordsInChunkArray, 0, newCoordsInChunkArray, 0, elems);</span>
<span class="fc" id="L1924">                System.arraycopy(colorsInChunkArray, 0, newColorsInChunkArray, 0, colorElems);</span>
<span class="fc" id="L1925">                System.arraycopy(normalsInChunkArray, 0, newNormalsInChunkArray, 0, elems);</span>

                // set new arrays
<span class="fc" id="L1928">                coordsInChunkArray = newCoordsInChunkArray;</span>
<span class="fc" id="L1929">                colorsInChunkArray = newColorsInChunkArray;</span>
<span class="fc" id="L1930">                normalsInChunkArray = newNormalsInChunkArray;</span>
<span class="fc" id="L1931">            } else {</span>
                // allow garbage collection
<span class="nc" id="L1933">                coordsInChunkArray = null;</span>
<span class="nc" id="L1934">                colorsInChunkArray = null;</span>
<span class="nc" id="L1935">                normalsInChunkArray = null;</span>
            }

<span class="pc bpc" id="L1938" title="1 of 2 branches missed.">            if (indicesInChunk &gt; 0) {</span>
<span class="fc" id="L1939">                final var newIndicesInChunkArray = new int[indicesInChunk];</span>
<span class="fc" id="L1940">                System.arraycopy(indicesInChunkArray, 0, newIndicesInChunkArray, 0, indicesInChunk);</span>

                // set new array
<span class="fc" id="L1943">                indicesInChunkArray = newIndicesInChunkArray;</span>
<span class="fc" id="L1944">            } else {</span>
                // allow garbage collection
<span class="nc" id="L1946">                indicesInChunkArray = null;</span>
<span class="nc" id="L1947">                originalIndicesInChunkArray = null;</span>
            }
<span class="fc" id="L1949">        }</span>

        /**
         * Reads header data to set up listeners capable of reading stream data
         * according to data types contained in header.
         *
         * @throws LoaderException Raised if file is corrupted (header is
         *                         invalid).
         * @throws IOException     if an I/O error occurs.
         */
        private void setUp() throws LoaderException, IOException {
<span class="fc" id="L1960">            endHeaderStreamPosition = reader.getPosition();</span>
<span class="fc" id="L1961">            var streamPositionOffset = endHeaderStreamPosition;</span>

            // read header to set up listeners
            try {
<span class="fc" id="L1965">                totalInstances = 0;</span>
<span class="fc" id="L1966">                colorComponents = 0;</span>
<span class="fc bfc" id="L1967" title="All 2 branches covered.">                for (final var element : loader.header.getElements()) {</span>
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">                    if (!element.isValidElement()) {</span>
<span class="nc" id="L1969">                        throw new LoaderException();</span>
                    }
<span class="fc" id="L1971">                    totalInstances += element.getNumberOfInstances();</span>

<span class="fc bfc" id="L1973" title="All 2 branches covered.">                    if (&quot;vertex&quot;.equals(element.getName())) {</span>
<span class="fc" id="L1974">                        vertexElement = element;</span>

                        // obtain position of first vertex

                        // obtain number of vertices
<span class="fc" id="L1979">                        numberOfVertices = element.getNumberOfInstances();</span>

<span class="fc" id="L1981">                        vertexDataSize = 0;</span>
<span class="fc bfc" id="L1982" title="All 2 branches covered.">                        for (final var property : element.getProperties()) {</span>

                            // set listener to read data from stream
<span class="fc" id="L1985">                            setReadValueFromStreamListener(property, loader.header.getStorageMode());</span>

                            // set listener to read data stored in buffer
<span class="fc bfc" id="L1988" title="All 11 branches covered.">                            switch (property.getName()) {</span>
                                case &quot;x&quot;:
<span class="fc" id="L1990">                                    verticesAvailable = true;</span>
<span class="pc bpc" id="L1991" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L1993">                                            property.setReadValueFromBufferListener(</span>
                                                    new Xint8ReadValueFromBufferListener());
<span class="nc" id="L1995">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L1997">                                            property.setReadValueFromBufferListener(</span>
                                                    new Xuint8ReadValueFromBufferListener());
<span class="nc" id="L1999">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2001">                                            property.setReadValueFromBufferListener(</span>
                                                    new Xint16ReadValueFromBufferListener());
<span class="nc" id="L2003">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2005">                                            property.setReadValueFromBufferListener(</span>
                                                    new Xuint16ReadValueFromBufferListener());
<span class="nc" id="L2007">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2009">                                            property.setReadValueFromBufferListener(</span>
                                                    new Xint32ReadValueFromBufferListener());
<span class="nc" id="L2011">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2013">                                            property.setReadValueFromBufferListener(</span>
                                                    new Xuint32ReadValueFromBufferListener());
<span class="nc" id="L2015">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2017">                                            property.setReadValueFromBufferListener(</span>
                                                    new Xfloat32ReadValueFromBufferListener());
<span class="nc" id="L2019">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2021">                                            property.setReadValueFromBufferListener(</span>
                                                    new Xfloat64ReadValueFromBufferListener());
<span class="nc" id="L2023">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2025">                                            property.setReadValueFromBufferListener(</span>
                                                    new XcharReadValueFromBufferListener());
<span class="nc" id="L2027">                                            break;</span>
                                        case PLY_UCHAR:
<span class="nc" id="L2029">                                            property.setReadValueFromBufferListener(</span>
                                                    new XucharReadValueFromBufferListener());
<span class="nc" id="L2031">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2033">                                            property.setReadValueFromBufferListener(</span>
                                                    new XshortReadValueFromBufferListener());
<span class="nc" id="L2035">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2037">                                            property.setReadValueFromBufferListener(</span>
                                                    new XushortReadValueFromBufferListener());
<span class="nc" id="L2039">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2041">                                            property.setReadValueFromBufferListener(</span>
                                                    new XintReadValueFromBufferListener());
<span class="nc" id="L2043">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2045">                                            property.setReadValueFromBufferListener(</span>
                                                    new XuintReadValueFromBufferListener());
<span class="nc" id="L2047">                                            break;</span>
                                        case PLY_FLOAT:
<span class="fc" id="L2049">                                            property.setReadValueFromBufferListener(</span>
                                                    new XfloatReadValueFromBufferListener());
<span class="fc" id="L2051">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2053">                                            property.setReadValueFromBufferListener(</span>
                                                    new XdoubleReadValueFromBufferListener());
<span class="nc" id="L2055">                                            break;</span>
                                        default:
<span class="nc" id="L2057">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;y&quot;:
<span class="fc" id="L2061">                                    verticesAvailable = true;</span>
<span class="pc bpc" id="L2062" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2064">                                            property.setReadValueFromBufferListener(</span>
                                                    new Yint8ReadValueFromBufferListener());
<span class="nc" id="L2066">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2068">                                            property.setReadValueFromBufferListener(</span>
                                                    new Yuint8ReadValueFromBufferListener());
<span class="nc" id="L2070">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2072">                                            property.setReadValueFromBufferListener(</span>
                                                    new Yint16ReadValueFromBufferListener());
<span class="nc" id="L2074">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2076">                                            property.setReadValueFromBufferListener(</span>
                                                    new Yuint16ReadValueFromBufferListener());
<span class="nc" id="L2078">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2080">                                            property.setReadValueFromBufferListener(</span>
                                                    new Yint32ReadValueFromBufferListener());
<span class="nc" id="L2082">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2084">                                            property.setReadValueFromBufferListener(</span>
                                                    new Yuint32ReadValueFromBufferListener());
<span class="nc" id="L2086">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2088">                                            property.setReadValueFromBufferListener(</span>
                                                    new Yfloat32ReadValueFromBufferListener());
<span class="nc" id="L2090">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2092">                                            property.setReadValueFromBufferListener(</span>
                                                    new Yfloat64ReadValueFromBufferListener());
<span class="nc" id="L2094">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2096">                                            property.setReadValueFromBufferListener(</span>
                                                    new YcharReadValueFromBufferListener());
<span class="nc" id="L2098">                                            break;</span>
                                        case PLY_UCHAR:
<span class="nc" id="L2100">                                            property.setReadValueFromBufferListener(</span>
                                                    new YucharReadValueFromBufferListener());
<span class="nc" id="L2102">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2104">                                            property.setReadValueFromBufferListener(</span>
                                                    new YshortReadValueFromBufferListener());
<span class="nc" id="L2106">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2108">                                            property.setReadValueFromBufferListener(</span>
                                                    new YushortReadValueFromBufferListener());
<span class="nc" id="L2110">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2112">                                            property.setReadValueFromBufferListener(</span>
                                                    new YintReadValueFromBufferListener());
<span class="nc" id="L2114">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2116">                                            property.setReadValueFromBufferListener(</span>
                                                    new YuintReadValueFromBufferListener());
<span class="nc" id="L2118">                                            break;</span>
                                        case PLY_FLOAT:
<span class="fc" id="L2120">                                            property.setReadValueFromBufferListener(</span>
                                                    new YfloatReadValueFromBufferListener());
<span class="fc" id="L2122">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2124">                                            property.setReadValueFromBufferListener(</span>
                                                    new YdoubleReadValueFromBufferListener());
<span class="nc" id="L2126">                                            break;</span>
                                        default:
<span class="nc" id="L2128">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;z&quot;:
<span class="fc" id="L2132">                                    verticesAvailable = true;</span>
<span class="pc bpc" id="L2133" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2135">                                            property.setReadValueFromBufferListener(</span>
                                                    new Zint8ReadValueFromBufferListener());
<span class="nc" id="L2137">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2139">                                            property.setReadValueFromBufferListener(</span>
                                                    new Zuint8ReadValueFromBufferListener());
<span class="nc" id="L2141">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2143">                                            property.setReadValueFromBufferListener(</span>
                                                    new Zint16ReadValueFromBufferListener());
<span class="nc" id="L2145">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2147">                                            property.setReadValueFromBufferListener(</span>
                                                    new Zuint16ReadValueFromBufferListener());
<span class="nc" id="L2149">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2151">                                            property.setReadValueFromBufferListener(</span>
                                                    new Zint32ReadValueFromBufferListener());
<span class="nc" id="L2153">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2155">                                            property.setReadValueFromBufferListener(</span>
                                                    new Zuint32ReadValueFromBufferListener());
<span class="nc" id="L2157">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2159">                                            property.setReadValueFromBufferListener(</span>
                                                    new Zfloat32ReadValueFromBufferListener());
<span class="nc" id="L2161">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2163">                                            property.setReadValueFromBufferListener(</span>
                                                    new Zfloat64ReadValueFromBufferListener());
<span class="nc" id="L2165">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2167">                                            property.setReadValueFromBufferListener(</span>
                                                    new ZcharReadValueFromBufferListener());
<span class="nc" id="L2169">                                            break;</span>
                                        case PLY_UCHAR:
<span class="nc" id="L2171">                                            property.setReadValueFromBufferListener(</span>
                                                    new ZucharReadValueFromBufferListener());
<span class="nc" id="L2173">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2175">                                            property.setReadValueFromBufferListener(</span>
                                                    new ZshortReadValueFromBufferListener());
<span class="nc" id="L2177">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2179">                                            property.setReadValueFromBufferListener(</span>
                                                    new ZushortReadValueFromBufferListener());
<span class="nc" id="L2181">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2183">                                            property.setReadValueFromBufferListener(</span>
                                                    new ZintReadValueFromBufferListener());
<span class="nc" id="L2185">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2187">                                            property.setReadValueFromBufferListener(</span>
                                                    new ZuintReadValueFromBufferListener());
<span class="nc" id="L2189">                                            break;</span>
                                        case PLY_FLOAT:
<span class="fc" id="L2191">                                            property.setReadValueFromBufferListener(</span>
                                                    new ZfloatReadValueFromBufferListener());
<span class="fc" id="L2193">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2195">                                            property.setReadValueFromBufferListener(</span>
                                                    new ZdoubleReadValueFromBufferListener());
<span class="nc" id="L2197">                                            break;</span>
                                        default:
<span class="nc" id="L2199">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;nx&quot;:
<span class="fc" id="L2203">                                    normalsAvailable = true;</span>
<span class="pc bpc" id="L2204" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2206">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXint8ReadValueFromBufferListener());
<span class="nc" id="L2208">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2210">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXuint8ReadValueFromBufferListener());
<span class="nc" id="L2212">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2214">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXint16ReadValueFromBufferListener());
<span class="nc" id="L2216">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2218">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXuint16ReadValueFromBufferListener());
<span class="nc" id="L2220">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2222">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXint32ReadValueFromBufferListener());
<span class="nc" id="L2224">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2226">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXuint32ReadValueFromBufferListener());
<span class="nc" id="L2228">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2230">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXfloat32ReadValueFromBufferListener());
<span class="nc" id="L2232">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2234">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXfloat64ReadValueFromBufferListener());
<span class="nc" id="L2236">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2238">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXcharReadValueFromBufferListener());
<span class="nc" id="L2240">                                            break;</span>
                                        case PLY_UCHAR:
<span class="nc" id="L2242">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXucharReadValueFromBufferListener());
<span class="nc" id="L2244">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2246">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXshortReadValueFromBufferListener());
<span class="nc" id="L2248">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2250">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXushortReadValueFromBufferListener());
<span class="nc" id="L2252">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2254">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXintReadValueFromBufferListener());
<span class="nc" id="L2256">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2258">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXuintReadValueFromBufferListener());
<span class="nc" id="L2260">                                            break;</span>
                                        case PLY_FLOAT:
<span class="fc" id="L2262">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXfloatReadValueFromBufferListener());
<span class="fc" id="L2264">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2266">                                            property.setReadValueFromBufferListener(</span>
                                                    new NXdoubleReadValueFromBufferListener());
<span class="nc" id="L2268">                                            break;</span>
                                        default:
<span class="nc" id="L2270">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;ny&quot;:
<span class="fc" id="L2274">                                    normalsAvailable = true;</span>
<span class="pc bpc" id="L2275" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2277">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYint8ReadValueFromBufferListener());
<span class="nc" id="L2279">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2281">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYuint8ReadValueFromBufferListener());
<span class="nc" id="L2283">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2285">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYint16ReadValueFromBufferListener());
<span class="nc" id="L2287">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2289">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYuint16ReadValueFromBufferListener());
<span class="nc" id="L2291">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2293">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYint32ReadValueFromBufferListener());
<span class="nc" id="L2295">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2297">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYuint32ReadValueFromBufferListener());
<span class="nc" id="L2299">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2301">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYfloat32ReadValueFromBufferListener());
<span class="nc" id="L2303">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2305">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYfloat64ReadValueFromBufferListener());
<span class="nc" id="L2307">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2309">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYcharReadValueFromBufferListener());
<span class="nc" id="L2311">                                            break;</span>
                                        case PLY_UCHAR:
<span class="nc" id="L2313">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYucharReadValueFromBufferListener());
<span class="nc" id="L2315">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2317">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYshortReadValueFromBufferListener());
<span class="nc" id="L2319">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2321">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYushortReadValueFromBufferListener());
<span class="nc" id="L2323">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2325">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYintReadValueFromBufferListener());
<span class="nc" id="L2327">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2329">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYuintReadValueFromBufferListener());
<span class="nc" id="L2331">                                            break;</span>
                                        case PLY_FLOAT:
<span class="fc" id="L2333">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYfloatReadValueFromBufferListener());
<span class="fc" id="L2335">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2337">                                            property.setReadValueFromBufferListener(</span>
                                                    new NYdoubleReadValueFromBufferListener());
<span class="nc" id="L2339">                                            break;</span>
                                        default:
<span class="nc" id="L2341">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;nz&quot;:
<span class="fc" id="L2345">                                    normalsAvailable = true;</span>
<span class="pc bpc" id="L2346" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2348">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZint8ReadValueFromBufferListener());
<span class="nc" id="L2350">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2352">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZuint8ReadValueFromBufferListener());
<span class="nc" id="L2354">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2356">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZint16ReadValueFromBufferListener());
<span class="nc" id="L2358">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2360">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZuint16ReadValueFromBufferListener());
<span class="nc" id="L2362">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2364">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZint32ReadValueFromBufferListener());
<span class="nc" id="L2366">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2368">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZuint32ReadValueFromBufferListener());
<span class="nc" id="L2370">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2372">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZfloat32ReadValueFromBufferListener());
<span class="nc" id="L2374">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2376">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZfloat64ReadValueFromBufferListener());
<span class="nc" id="L2378">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2380">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZcharReadValueFromBufferListener());
<span class="nc" id="L2382">                                            break;</span>
                                        case PLY_UCHAR:
<span class="nc" id="L2384">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZucharReadValueFromBufferListener());
<span class="nc" id="L2386">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2388">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZshortReadValueFromBufferListener());
<span class="nc" id="L2390">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2392">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZushortReadValueFromBufferListener());
<span class="nc" id="L2394">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2396">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZintReadValueFromBufferListener());
<span class="nc" id="L2398">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2400">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZuintReadValueFromBufferListener());
<span class="nc" id="L2402">                                            break;</span>
                                        case PLY_FLOAT:
<span class="fc" id="L2404">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZfloatReadValueFromBufferListener());
<span class="fc" id="L2406">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2408">                                            property.setReadValueFromBufferListener(</span>
                                                    new NZdoubleReadValueFromBufferListener());
<span class="nc" id="L2410">                                            break;</span>
                                        default:
<span class="nc" id="L2412">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;red&quot;:
<span class="fc" id="L2416">                                    colorsAvailable = true;</span>
<span class="fc" id="L2417">                                    colorComponents++;</span>
<span class="pc bpc" id="L2418" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2420">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedInt8ReadValueFromBufferListener());
<span class="nc" id="L2422">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2424">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedUint8ReadValueFromBufferListener());
<span class="nc" id="L2426">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2428">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedInt16ReadValueFromBufferListener());
<span class="nc" id="L2430">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2432">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedUint16ReadValueFromBufferListener());
<span class="nc" id="L2434">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2436">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedInt32ReadValueFromBufferListener());
<span class="nc" id="L2438">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2440">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedUint32ReadValueFromBufferListener());
<span class="nc" id="L2442">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2444">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedFloat32ReadValueFromBufferListener());
<span class="nc" id="L2446">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2448">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedFloat64ReadValueFromBufferListener());
<span class="nc" id="L2450">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2452">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedCharReadValueFromBufferListener());
<span class="nc" id="L2454">                                            break;</span>
                                        case PLY_UCHAR:
<span class="fc" id="L2456">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedUcharReadValueFromBufferListener());
<span class="fc" id="L2458">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2460">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedShortReadValueFromBufferListener());
<span class="nc" id="L2462">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2464">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedUshortReadValueFromBufferListener());
<span class="nc" id="L2466">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2468">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedIntReadValueFromBufferListener());
<span class="nc" id="L2470">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2472">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedUintReadValueFromBufferListener());
<span class="nc" id="L2474">                                            break;</span>
                                        case PLY_FLOAT:
<span class="nc" id="L2476">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedFloatReadValueFromBufferListener());
<span class="nc" id="L2478">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2480">                                            property.setReadValueFromBufferListener(</span>
                                                    new RedDoubleReadValueFromBufferListener());
<span class="nc" id="L2482">                                            break;</span>
                                        default:
<span class="nc" id="L2484">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;green&quot;:
<span class="fc" id="L2488">                                    colorsAvailable = true;</span>
<span class="fc" id="L2489">                                    colorComponents++;</span>
<span class="pc bpc" id="L2490" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2492">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenInt8ReadValueFromBufferListener());
<span class="nc" id="L2494">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2496">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenUint8ReadValueFromBufferListener());
<span class="nc" id="L2498">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2500">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenInt16ReadValueFromBufferListener());
<span class="nc" id="L2502">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2504">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenUint16ReadValueFromBufferListener());
<span class="nc" id="L2506">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2508">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenInt32ReadValueFromBufferListener());
<span class="nc" id="L2510">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2512">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenUint32ReadValueFromBufferListener());
<span class="nc" id="L2514">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2516">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenFloat32ReadValueFromBufferListener());
<span class="nc" id="L2518">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2520">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenFloat64ReadValueFromBufferListener());
<span class="nc" id="L2522">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2524">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenCharReadValueFromBufferListener());
<span class="nc" id="L2526">                                            break;</span>
                                        case PLY_UCHAR:
<span class="fc" id="L2528">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenUcharReadValueFromBufferListener());
<span class="fc" id="L2530">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2532">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenShortReadValueFromBufferListener());
<span class="nc" id="L2534">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2536">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenUshortReadValueFromBufferListener());
<span class="nc" id="L2538">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2540">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenIntReadValueFromBufferListener());
<span class="nc" id="L2542">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2544">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenUintReadValueFromBufferListener());
<span class="nc" id="L2546">                                            break;</span>
                                        case PLY_FLOAT:
<span class="nc" id="L2548">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenFloatReadValueFromBufferListener());
<span class="nc" id="L2550">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2552">                                            property.setReadValueFromBufferListener(</span>
                                                    new GreenDoubleReadValueFromBufferListener());
<span class="nc" id="L2554">                                            break;</span>
                                        default:
<span class="nc" id="L2556">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;blue&quot;:
<span class="fc" id="L2560">                                    colorsAvailable = true;</span>
<span class="fc" id="L2561">                                    colorComponents++;</span>
<span class="pc bpc" id="L2562" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2564">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueInt8ReadValueFromBufferListener());
<span class="nc" id="L2566">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2568">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueUint8ReadValueFromBufferListener());
<span class="nc" id="L2570">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2572">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueInt16ReadValueFromBufferListener());
<span class="nc" id="L2574">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2576">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueUint16ReadValueFromBufferListener());
<span class="nc" id="L2578">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2580">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueInt32ReadValueFromBufferListener());
<span class="nc" id="L2582">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2584">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueUint32ReadValueFromBufferListener());
<span class="nc" id="L2586">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2588">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueFloat32ReadValueFromBufferListener());
<span class="nc" id="L2590">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2592">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueFloat64ReadValueFromBufferListener());
<span class="nc" id="L2594">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2596">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueCharReadValueFromBufferListener());
<span class="nc" id="L2598">                                            break;</span>
                                        case PLY_UCHAR:
<span class="fc" id="L2600">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueUcharReadValueFromBufferListener());
<span class="fc" id="L2602">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2604">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueShortReadValueFromBufferListener());
<span class="nc" id="L2606">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2608">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueUshortReadValueFromBufferListener());
<span class="nc" id="L2610">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2612">                                            property.setReadLengthValueFromBufferListener(</span>
                                                    new BlueIntReadValueFromBufferListener());
<span class="nc" id="L2614">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2616">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueUintReadValueFromBufferListener());
<span class="nc" id="L2618">                                            break;</span>
                                        case PLY_FLOAT:
<span class="nc" id="L2620">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueFloatReadValueFromBufferListener());
<span class="nc" id="L2622">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2624">                                            property.setReadValueFromBufferListener(</span>
                                                    new BlueDoubleReadValueFromBufferListener());
<span class="nc" id="L2626">                                            break;</span>
                                        default:
<span class="nc" id="L2628">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                case &quot;alpha&quot;:
<span class="fc" id="L2632">                                    colorsAvailable = true;</span>
<span class="fc" id="L2633">                                    colorComponents++;</span>
<span class="pc bpc" id="L2634" title="16 of 17 branches missed.">                                    switch (property.getValueType()) {</span>
                                        case PLY_INT8:
<span class="nc" id="L2636">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaInt8ReadValueFromBufferListener());
<span class="nc" id="L2638">                                            break;</span>
                                        case PLY_UINT8:
<span class="nc" id="L2640">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaUint8ReadValueFromBufferListener());
<span class="nc" id="L2642">                                            break;</span>
                                        case PLY_INT16:
<span class="nc" id="L2644">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaInt16ReadValueFromBufferListener());
<span class="nc" id="L2646">                                            break;</span>
                                        case PLY_UINT16:
<span class="nc" id="L2648">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaUint16ReadValueFromBufferListener());
<span class="nc" id="L2650">                                            break;</span>
                                        case PLY_INT32:
<span class="nc" id="L2652">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaInt32ReadValueFromBufferListener());
<span class="nc" id="L2654">                                            break;</span>
                                        case PLY_UINT32:
<span class="nc" id="L2656">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaUint32ReadValueFromBufferListener());
<span class="nc" id="L2658">                                            break;</span>
                                        case PLY_FLOAT32:
<span class="nc" id="L2660">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaFloat32ReadValueFromBufferListener());
<span class="nc" id="L2662">                                            break;</span>
                                        case PLY_FLOAT64:
<span class="nc" id="L2664">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaFloat64ReadValueFromBufferListener());
<span class="nc" id="L2666">                                            break;</span>
                                        case PLY_CHAR:
<span class="nc" id="L2668">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaCharReadValueFromBufferListener());
<span class="nc" id="L2670">                                            break;</span>
                                        case PLY_UCHAR:
<span class="fc" id="L2672">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaUcharReadValueFromBufferListener());
<span class="fc" id="L2674">                                            break;</span>
                                        case PLY_SHORT:
<span class="nc" id="L2676">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaShortReadValueFromBufferListener());
<span class="nc" id="L2678">                                            break;</span>
                                        case PLY_USHORT:
<span class="nc" id="L2680">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaUshortReadValueFromBufferListener());
<span class="nc" id="L2682">                                            break;</span>
                                        case PLY_INT:
<span class="nc" id="L2684">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaIntReadValueFromBufferListener());
<span class="nc" id="L2686">                                            break;</span>
                                        case PLY_UINT:
<span class="nc" id="L2688">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaUintReadValueFromBufferListener());
<span class="nc" id="L2690">                                            break;</span>
                                        case PLY_FLOAT:
<span class="nc" id="L2692">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaFloatReadValueFromBufferListener());
<span class="nc" id="L2694">                                            break;</span>
                                        case PLY_DOUBLE:
<span class="nc" id="L2696">                                            property.setReadValueFromBufferListener(</span>
                                                    new AlphaDoubleReadValueFromBufferListener());
<span class="nc" id="L2698">                                            break;</span>
                                        default:
<span class="nc" id="L2700">                                            throw new LoaderException();</span>
                                    }
                                    break;
                                default:
                                    // not recognized properties are ignored
                                    break;
                            }

                            // update vertex data size
<span class="fc bfc" id="L2709" title="All 2 branches covered.">                            if (loader.header.getStorageMode() != PLYStorageMode.PLY_ASCII) {</span>
<span class="fc" id="L2710">                                vertexDataSize += sizeForDataType(property.getValueType());</span>
                            }
<span class="fc" id="L2712">                        }</span>

<span class="pc bpc" id="L2714" title="1 of 4 branches missed.">                        if (loader.header.getStorageMode() != PLYStorageMode.PLY_ASCII</span>
                                &amp;&amp; !firstFaceStreamPositionAvailable) {

<span class="fc" id="L2717">                            firstVertexStreamPosition = streamPositionOffset;</span>
<span class="fc" id="L2718">                            firstVertexStreamPositionAvailable = true;</span>
                            // update offset taking into account all vertex data
<span class="fc" id="L2720">                            streamPositionOffset += numberOfVertices * vertexDataSize;</span>
                        }

<span class="pc bpc" id="L2723" title="1 of 2 branches missed.">                    } else if (&quot;face&quot;.equals(element.getName())) {</span>
<span class="fc" id="L2724">                        faceElement = element;</span>
<span class="fc" id="L2725">                        indicesAvailable = true;</span>

                        // obtain number of faces
<span class="fc" id="L2728">                        numberOfFaces = element.getNumberOfInstances();</span>

<span class="fc bfc" id="L2730" title="All 2 branches covered.">                        for (final var property : element.getProperties()) {</span>

                            // set listener to read data from stream
<span class="fc" id="L2733">                            setReadValueFromStreamListener(property, loader.header.getStorageMode());</span>

<span class="pc bpc" id="L2735" title="1 of 2 branches missed.">                            if (property.getPropertyType() == PropertyTypePLY.PROPERTY_PLY_LIST) {</span>
                                // set listeners to get number of elements in a
                                // list
<span class="fc" id="L2738">                                setReadLengthValueFromBufferListener(property);</span>
<span class="fc" id="L2739">                                setReadLengthValueFromStreamListener(property, loader.header.getStorageMode());</span>
                            }

<span class="pc bpc" id="L2742" title="16 of 17 branches missed.">                            switch (property.getValueType()) {</span>
                                case PLY_INT8:
<span class="nc" id="L2744">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceInt8ReadValueFromBufferListener());
<span class="nc" id="L2746">                                    break;</span>
                                case PLY_UINT8:
<span class="nc" id="L2748">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceUint8ReadValueFromBufferListener());
<span class="nc" id="L2750">                                    break;</span>
                                case PLY_INT16:
<span class="nc" id="L2752">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceInt16ReadValueFromBufferListener());
<span class="nc" id="L2754">                                    break;</span>
                                case PLY_UINT16:
<span class="nc" id="L2756">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceUint16ReadValueFromBufferListener());
<span class="nc" id="L2758">                                    break;</span>
                                case PLY_INT32:
<span class="nc" id="L2760">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceInt32ReadValueFromBufferListener());
<span class="nc" id="L2762">                                    break;</span>
                                case PLY_UINT32:
<span class="nc" id="L2764">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceUint32ReadValueFromBufferListener());
<span class="nc" id="L2766">                                    break;</span>
                                case PLY_FLOAT32:
<span class="nc" id="L2768">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceFloat32ReadValueFromBufferListener());
<span class="nc" id="L2770">                                    break;</span>
                                case PLY_FLOAT64:
<span class="nc" id="L2772">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceFloat64ReadValueFromBufferListener());
<span class="nc" id="L2774">                                    break;</span>
                                case PLY_CHAR:
<span class="nc" id="L2776">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceCharReadValueFromBufferListener());
<span class="nc" id="L2778">                                    break;</span>
                                case PLY_UCHAR:
<span class="nc" id="L2780">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceUcharReadValueFromBufferListener());
<span class="nc" id="L2782">                                    break;</span>
                                case PLY_SHORT:
<span class="nc" id="L2784">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceShortReadValueFromBufferListener());
<span class="nc" id="L2786">                                    break;</span>
                                case PLY_USHORT:
<span class="nc" id="L2788">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceUshortReadValueFromBufferListener());
<span class="nc" id="L2790">                                    break;</span>
                                case PLY_INT:
<span class="fc" id="L2792">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceIntReadValueFromBufferListener());
<span class="fc" id="L2794">                                    break;</span>
                                case PLY_UINT:
<span class="nc" id="L2796">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceUintReadValueFromBufferListener());
<span class="nc" id="L2798">                                    break;</span>
                                case PLY_FLOAT:
<span class="nc" id="L2800">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceFloatReadValueFromBufferListener());
<span class="nc" id="L2802">                                    break;</span>
                                case PLY_DOUBLE:
<span class="nc" id="L2804">                                    property.setReadValueFromBufferListener(</span>
                                            new FaceDoubleReadValueFromBufferListener());
<span class="nc" id="L2806">                                    break;</span>
                                default:
<span class="nc" id="L2808">                                    throw new LoaderException();</span>
                            }
<span class="fc" id="L2810">                        }</span>

<span class="fc bfc" id="L2812" title="All 2 branches covered.">                        if (loader.header.getStorageMode() != PLYStorageMode.PLY_ASCII) {</span>
                            // Binary storage mode (either Little endian or Big
                            // endian)
<span class="fc" id="L2815">                            firstFaceStreamPosition = streamPositionOffset;</span>
<span class="fc" id="L2816">                            firstFaceStreamPositionAvailable = true;</span>

<span class="fc" id="L2818">                            fetchVertexListener = new BinaryVertexFetcherListener();</span>
                        } else {
                            // ASCII storage mode
<span class="fc" id="L2821">                            fetchVertexListener = new AsciiVertexFetcherListener();</span>
                        }
                    }
<span class="fc" id="L2824">                }</span>

                // find first vertex and face positions in stream in case it
                // couldn't be computed
<span class="fc" id="L2828">                findFirstVertexAndFaceStreamPosition();</span>

                // set stream into 1st face position
<span class="pc bpc" id="L2831" title="1 of 2 branches missed.">                if (!firstFaceStreamPositionAvailable) {</span>
<span class="nc" id="L2832">                    throw new LoaderException();</span>
                }
<span class="fc" id="L2834">                reader.seek(firstFaceStreamPosition);</span>
<span class="fc" id="L2835">                currentFace = 0;</span>

<span class="nc" id="L2837">            } catch (final NotAvailableException e) {</span>
<span class="nc" id="L2838">                throw new LoaderException(e);</span>
<span class="fc" id="L2839">            }</span>
<span class="fc" id="L2840">        }</span>

        /**
         * Returns size in bytes for a given data type.
         *
         * @param type A data type.
         * @return Size in bytes for a given data type.
         */
        private long sizeForDataType(final DataTypePLY type) {
<span class="pc bpc" id="L2849" title="2 of 4 branches missed.">            return switch (type) {</span>
<span class="fc" id="L2850">                case PLY_INT8, PLY_UINT8, PLY_CHAR, PLY_UCHAR -&gt; 1; // 1 byte</span>
<span class="nc" id="L2851">                case PLY_INT16, PLY_UINT16, PLY_SHORT, PLY_USHORT -&gt; 2; // 2 bytes</span>
<span class="fc" id="L2852">                case PLY_INT32, PLY_UINT32, PLY_FLOAT32, PLY_INT, PLY_UINT, PLY_FLOAT -&gt; 4; // 4 bytes</span>
<span class="nc" id="L2853">                case PLY_FLOAT64, PLY_DOUBLE -&gt; 8; // 8 bytes</span>
            };
        }

        /**
         * Finds in file stream the location of the first vertex and face.
         *
         * @throws LoaderException       Raised if file is corrupted and location of
         *                               first vertex or face cannot be found.
         * @throws NotAvailableException Raised if header does not contain a
         *                               given element.
         * @throws IOException           if an I/O error occurs.
         */
        private void findFirstVertexAndFaceStreamPosition() throws LoaderException, NotAvailableException, IOException {

<span class="pc bpc" id="L2868" title="1 of 4 branches missed.">            if (firstVertexStreamPositionAvailable &amp;&amp; firstFaceStreamPositionAvailable) {</span>
                // already computed
<span class="fc" id="L2870">                return;</span>
            }

<span class="fc" id="L2873">            final var buffer = ByteBuffer.allocate(BUFFER_SIZE);</span>

            long nElems;
<span class="fc" id="L2876">            var counter = 0L;</span>

            // iterate over elements in header
<span class="pc bpc" id="L2879" title="1 of 2 branches missed.">            for (final var element : loader.header.getElements()) {</span>
<span class="pc bpc" id="L2880" title="1 of 2 branches missed.">                if (!element.isValidElement()) {</span>
<span class="nc" id="L2881">                    throw new LoaderException();</span>
                }

<span class="fc" id="L2884">                var stop = false;</span>
<span class="fc bfc" id="L2885" title="All 2 branches covered.">                if (&quot;vertex&quot;.equals(element.getName())) {</span>
                    // FIRST VERTEX FOUND!
<span class="fc" id="L2887">                    firstVertexStreamPosition = reader.getPosition();</span>
<span class="fc" id="L2888">                    firstVertexStreamPositionAvailable = true;</span>

<span class="fc" id="L2890">                    vertexElement = element;</span>

                    // stop if both 1st vertex and face are known
<span class="fc" id="L2893">                    stop = firstFaceStreamPositionAvailable;</span>
<span class="pc bpc" id="L2894" title="1 of 2 branches missed.">                } else if (&quot;face&quot;.equals(element.getName())) {</span>
                    // FIRST FACE FOUND!
<span class="fc" id="L2896">                    firstFaceStreamPosition = reader.getPosition();</span>
<span class="fc" id="L2897">                    firstFaceStreamPositionAvailable = true;</span>

<span class="fc" id="L2899">                    faceElement = element;</span>

                    // stop if both 1st vertex and face are known
<span class="fc" id="L2902">                    stop = firstVertexStreamPositionAvailable;</span>
                }

<span class="fc bfc" id="L2905" title="All 2 branches covered.">                if (stop) {</span>
<span class="fc" id="L2906">                    break;</span>
                }

<span class="fc" id="L2909">                nElems = element.getNumberOfInstances();</span>
                // repeat properties iteration for each element
<span class="fc bfc" id="L2911" title="All 2 branches covered.">                for (var i = 0L; i &lt; nElems; i++) {</span>

                    PLYReadValueFromStreamListener readLengthValueFromStreamListener;
                    PLYReadValueFromBufferListener readLengthValueFromBufferListener;
                    PLYReadValueFromStreamListener readValueFromStreamListener;

                    // iterate on properties of element
<span class="fc bfc" id="L2918" title="All 2 branches covered.">                    for (final var property : element.getProperties()) {</span>
<span class="pc bpc" id="L2919" title="1 of 2 branches missed.">                        if (!property.isValidProperty()) {</span>
<span class="nc" id="L2920">                            throw new LoaderException();</span>
                        }

                        // number of elements in list (initially assume that is
                        // scalar, hence 1
<span class="fc" id="L2925">                        listElems = 1;</span>

<span class="pc bpc" id="L2927" title="1 of 2 branches missed.">                        if (property.getPropertyType() == PropertyTypePLY.PROPERTY_PLY_LIST) {</span>
                            // read number of list elements
<span class="nc" id="L2929">                            readLengthValueFromStreamListener = property.getReadLengthValueFromStreamListener();</span>
<span class="nc" id="L2930">                            readLengthValueFromStreamListener.readFromStream(buffer);</span>

<span class="nc bnc" id="L2932" title="All 4 branches missed.">                            if (reader.isEndOfStream() &amp;&amp; (counter &lt; (totalInstances - 1))) {</span>
<span class="nc" id="L2933">                                throw new LoaderException();</span>
                            }

<span class="nc" id="L2936">                            readLengthValueFromBufferListener = property.getReadLengthValueFromBufferListener();</span>
<span class="nc" id="L2937">                            readLengthValueFromBufferListener.readValueFromBuffer(buffer);</span>
                        }

                        // set delegate to read from stream
<span class="fc" id="L2941">                        readValueFromStreamListener = property.getReadValueFromStreamListener();</span>

                        // read property data
<span class="fc bfc" id="L2944" title="All 2 branches covered.">                        for (var u = 0L; u &lt; listElems; u++) {</span>
<span class="fc" id="L2945">                            readValueFromStreamListener.readFromStream(buffer);</span>

<span class="pc bpc" id="L2947" title="3 of 4 branches missed.">                            if (reader.isEndOfStream() &amp;&amp; (counter &lt; (totalInstances - 1))) {</span>
<span class="nc" id="L2948">                                throw new LoaderException();</span>
                            }
                        }
<span class="fc" id="L2951">                    }</span>

<span class="fc" id="L2953">                    counter++;</span>
                }
<span class="fc" id="L2955">            }</span>
<span class="fc" id="L2956">        }</span>

        /**
         * Class to fetch vertex position within the file stream for a binary.
         * file.
         */
<span class="fc" id="L2962">        private class BinaryVertexFetcherListener implements VertexFetcherListener {</span>

            /**
             * Fetches vertex position and sets current stream position to
             * desired vertex.
             *
             * @param index index of vertex to be searched.
             * @throws LoaderException if file is corrupted.
             * @throws IOException     if an I/O error occurs.
             */
            @Override
            public void fetch(final long index) throws LoaderException, IOException {

<span class="fc" id="L2975">                final var nElems = vertexElement.getNumberOfInstances();</span>
<span class="pc bpc" id="L2976" title="1 of 2 branches missed.">                if (index &gt;= nElems) {</span>
<span class="nc" id="L2977">                    throw new LoaderException();</span>
                }

<span class="fc" id="L2980">                final var pos = firstVertexStreamPosition + (index * vertexDataSize);</span>
<span class="fc bfc" id="L2981" title="All 2 branches covered.">                if (reader.getPosition() != pos) {</span>
<span class="fc" id="L2982">                    reader.seek(pos);</span>
                }
<span class="fc" id="L2984">            }</span>
        }

        /**
         * Class to fetch vertex position within the file stream for an ascii
         * file.
         */
<span class="fc" id="L2991">        private class AsciiVertexFetcherListener implements VertexFetcherListener {</span>

            /**
             * Fetches vertex position and sets current stream position to
             * desired vertex.
             *
             * @param index index of vertex to be searched.
             * @throws LoaderException       if file is corrupted.
             * @throws IOException           if an I/O error occurs.
             * @throws NotAvailableException if a given element in the header
             *                               is not available.
             */
            @Override
            public void fetch(final long index) throws LoaderException, IOException, NotAvailableException {

<span class="fc" id="L3006">                final var nElems = vertexElement.getNumberOfInstances();</span>
<span class="pc bpc" id="L3007" title="1 of 2 branches missed.">                if (index &gt;= nElems) {</span>
<span class="nc" id="L3008">                    throw new LoaderException();</span>
                }

<span class="fc" id="L3011">                final var fetchBuffer = ByteBuffer.allocate(BUFFER_SIZE);</span>

<span class="fc" id="L3013">                var startStreamPos = firstVertexStreamPosition;</span>
<span class="fc" id="L3014">                var startIndex = 0L;</span>

<span class="fc bfc" id="L3016" title="All 2 branches covered.">                if (!verticesStreamPositionsMap.isEmpty()) {</span>
                    // with floorEntry, we will pick element immediately
                    // before or equal to index if any exists
<span class="fc" id="L3019">                    final var entry = verticesStreamPositionsMap.floorEntry(index);</span>
<span class="pc bpc" id="L3020" title="1 of 2 branches missed.">                    if (entry != null) {</span>
<span class="fc" id="L3021">                        final var origIndex = entry.getKey();</span>
<span class="fc" id="L3022">                        final var pos = entry.getValue();</span>
<span class="pc bpc" id="L3023" title="2 of 4 branches missed.">                        if ((origIndex &lt;= index) &amp;&amp; (pos &gt;= 0)) {</span>
<span class="fc" id="L3024">                            startIndex = origIndex;</span>
<span class="fc" id="L3025">                            startStreamPos = pos;</span>
                        }
                    }
                }

                // if we need to read next vertex, don't do anything, otherwise
                // move to next vertex location if reading some vertex located
                // further on the stream. For previous vertex indices, start from
                // beginning
<span class="fc bfc" id="L3034" title="All 2 branches covered.">                if (reader.getPosition() != startStreamPos) {</span>
<span class="fc" id="L3035">                    reader.seek(startStreamPos);</span>
                }

                // read from stream until start of data of desired vertex
<span class="fc bfc" id="L3039" title="All 2 branches covered.">                for (var i = startIndex; i &lt; index; i++) {</span>

                    // when traversing stream of data until reaching desired
                    // index, we add all vertex positions into map
<span class="fc" id="L3043">                    final var streamPosition = reader.getPosition();</span>
<span class="fc" id="L3044">                    addVertexPositionToMap(i, streamPosition);</span>

                    PLYReadValueFromStreamListener readValueFromStreamListener;

                    // iterate on vertex element properties
<span class="fc bfc" id="L3049" title="All 2 branches covered.">                    for (final var property : vertexElement.getProperties()) {</span>
<span class="pc bpc" id="L3050" title="1 of 2 branches missed.">                        if (!property.isValidProperty()) {</span>
<span class="nc" id="L3051">                            throw new LoaderException();</span>
                        }

                        // set delegates to read property value
<span class="fc" id="L3055">                        readValueFromStreamListener = property.getReadValueFromStreamListener();</span>
                        // and read value
<span class="fc" id="L3057">                        readValueFromStreamListener.readFromStream(fetchBuffer);</span>

<span class="pc bpc" id="L3059" title="3 of 4 branches missed.">                        if (reader.isEndOfStream() &amp;&amp; (i &lt; (index - 1))) {</span>
<span class="nc" id="L3060">                            throw new LoaderException();</span>
                        }
<span class="fc" id="L3062">                    }</span>
                }

<span class="fc" id="L3065">                vertexStreamPosition = reader.getPosition();</span>
<span class="fc" id="L3066">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using int8 data type.
         */
<span class="nc" id="L3072">        private class Xint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3082">                loaderIterator.coordX = buffer.get(0);</span>
<span class="nc" id="L3083">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using int8 data type.
         */
<span class="nc" id="L3089">        private class Yint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3099">                loaderIterator.coordY = buffer.get(0);</span>
<span class="nc" id="L3100">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using int8 data type.
         */
<span class="nc" id="L3106">        private class Zint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3116">                loaderIterator.coordZ = buffer.get(0);</span>
<span class="nc" id="L3117">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using uint8 data type.
         */
<span class="nc" id="L3123">        private class Xuint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3135">                loaderIterator.coordX = buffer.getShort(0);</span>
<span class="nc" id="L3136">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using uint8 data type.
         */
<span class="nc" id="L3142">        private class Yuint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3154">                loaderIterator.coordY = buffer.getShort(0);</span>
<span class="nc" id="L3155">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using uint8 data type.
         */
<span class="nc" id="L3161">        private class Zuint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3173">                loaderIterator.coordZ = buffer.getShort(0);</span>
<span class="nc" id="L3174">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using int16 data type.
         */
<span class="nc" id="L3180">        private class Xint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3190">                loaderIterator.coordX = buffer.getShort(0);</span>
<span class="nc" id="L3191">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using int16 data type.
         */
<span class="nc" id="L3197">        private class Yint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3207">                loaderIterator.coordY = buffer.getShort(0);</span>
<span class="nc" id="L3208">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using int16 data type.
         */
<span class="nc" id="L3214">        private class Zint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3224">                loaderIterator.coordZ = buffer.getShort(0);</span>
<span class="nc" id="L3225">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using uint16 data
         * type.
         */
<span class="nc" id="L3232">        private class Xuint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3244">                loaderIterator.coordX = buffer.getInt(0);</span>
<span class="nc" id="L3245">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using uint16 data
         * type.
         */
<span class="nc" id="L3252">        private class Yuint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3264">                loaderIterator.coordY = buffer.getInt(0);</span>
<span class="nc" id="L3265">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using uint16 data
         * type.
         */
<span class="nc" id="L3272">        private class Zuint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3284">                loaderIterator.coordZ = buffer.getInt(0);</span>
<span class="nc" id="L3285">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using int32 data type.
         */
<span class="nc" id="L3291">        private class Xint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3301">                loaderIterator.coordX = buffer.getInt(0);</span>
<span class="nc" id="L3302">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using int32 data type.
         */
<span class="nc" id="L3308">        private class Yint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3318">                loaderIterator.coordY = buffer.getInt(0);</span>
<span class="nc" id="L3319">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using int32 data type.
         */
<span class="nc" id="L3325">        private class Zint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3335">                loaderIterator.coordZ = buffer.getInt(0);</span>
<span class="nc" id="L3336">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using uint32 data
         * type.
         */
<span class="nc" id="L3343">        private class Xuint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3355">                loaderIterator.coordX = buffer.getLong(0);</span>
<span class="nc" id="L3356">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using uint32 data
         * type.
         */
<span class="nc" id="L3363">        private class Yuint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3375">                loaderIterator.coordY = buffer.getLong(0);</span>
<span class="nc" id="L3376">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using uint32 data
         * type.
         */
<span class="nc" id="L3383">        private class Zuint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3395">                loaderIterator.coordZ = buffer.getLong(0);</span>
<span class="nc" id="L3396">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using float32 data
         * type.
         */
<span class="nc" id="L3403">        private class Xfloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3413">                loaderIterator.coordX = buffer.getFloat(0);</span>
<span class="nc" id="L3414">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using float32 data
         * type.
         */
<span class="nc" id="L3421">        private class Yfloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3431">                loaderIterator.coordY = buffer.getFloat(0);</span>
<span class="nc" id="L3432">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using float32 data
         * type.
         */
<span class="nc" id="L3439">        private class Zfloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3449">                loaderIterator.coordZ = buffer.getFloat(0);</span>
<span class="nc" id="L3450">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using float64 data
         * type.
         */
<span class="nc" id="L3457">        private class Xfloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3467">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L3469">                loaderIterator.coordX = (float) value;</span>
<span class="nc" id="L3470">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using float64 data
         * type.
         */
<span class="nc" id="L3477">        private class Yfloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3487">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L3489">                loaderIterator.coordY = (float) value;</span>
<span class="nc" id="L3490">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using float64 data
         * type.
         */
<span class="nc" id="L3497">        private class Zfloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3507">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L3509">                loaderIterator.coordZ = (float) value;</span>
<span class="nc" id="L3510">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using char data type.
         */
<span class="nc" id="L3516">        private class XcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3526">                loaderIterator.coordX = buffer.get(0);</span>
<span class="nc" id="L3527">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using char data type.
         */
<span class="nc" id="L3533">        private class YcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3543">                loaderIterator.coordY = buffer.get(0);</span>
<span class="nc" id="L3544">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using char data type.
         */
<span class="nc" id="L3550">        private class ZcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3560">                loaderIterator.coordZ = buffer.get(0);</span>
<span class="nc" id="L3561">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using uchar data type.
         */
<span class="nc" id="L3567">        private class XucharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3579">                loaderIterator.coordX = buffer.getShort(0);</span>
<span class="nc" id="L3580">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using uchar data type.
         */
<span class="nc" id="L3586">        private class YucharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3598">                loaderIterator.coordY = buffer.getShort(0);</span>
<span class="nc" id="L3599">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using uchar data type.
         */
<span class="nc" id="L3605">        private class ZucharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3617">                loaderIterator.coordZ = buffer.getShort(0);</span>
<span class="nc" id="L3618">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using short data type.
         */
<span class="nc" id="L3624">        private class XshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3634">                loaderIterator.coordX = buffer.getShort(0);</span>
<span class="nc" id="L3635">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using short data type.
         */
<span class="nc" id="L3641">        private class YshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3651">                loaderIterator.coordY = buffer.getShort(0);</span>
<span class="nc" id="L3652">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using short data type.
         */
<span class="nc" id="L3658">        private class ZshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3668">                loaderIterator.coordZ = buffer.getShort(0);</span>
<span class="nc" id="L3669">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using ushort data
         * type.
         */
<span class="nc" id="L3676">        private class XushortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3688">                loaderIterator.coordX = buffer.getInt(0);</span>
<span class="nc" id="L3689">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using ushort data
         * type.
         */
<span class="nc" id="L3696">        private class YushortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3708">                loaderIterator.coordY = buffer.getInt(0);</span>
<span class="nc" id="L3709">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using ushort data
         * type.
         */
<span class="nc" id="L3716">        private class ZushortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3728">                loaderIterator.coordZ = buffer.getInt(0);</span>
<span class="nc" id="L3729">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using int data type.
         */
<span class="nc" id="L3735">        private class XintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3745">                loaderIterator.coordX = buffer.getInt(0);</span>
<span class="nc" id="L3746">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using int data type.
         */
<span class="nc" id="L3752">        private class YintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3762">                loaderIterator.coordY = buffer.getInt(0);</span>
<span class="nc" id="L3763">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using int data type.
         */
<span class="nc" id="L3769">        private class ZintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3779">                loaderIterator.coordZ = buffer.getInt(0);</span>
<span class="nc" id="L3780">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using uint data type.
         */
<span class="nc" id="L3786">        private class XuintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3798">                loaderIterator.coordX = buffer.getLong(0);</span>
<span class="nc" id="L3799">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using uint data type.
         */
<span class="nc" id="L3805">        private class YuintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3817">                loaderIterator.coordY = buffer.getLong(0);</span>
<span class="nc" id="L3818">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using uint data type.
         */
<span class="nc" id="L3824">        private class ZuintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L3836">                loaderIterator.coordZ = buffer.getLong(0);</span>
<span class="nc" id="L3837">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using float data type.
         */
<span class="fc" id="L3843">        private class XfloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="fc" id="L3853">                loaderIterator.coordX = buffer.getFloat(0);</span>
<span class="fc" id="L3854">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using float data type.
         */
<span class="fc" id="L3860">        private class YfloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="fc" id="L3870">                loaderIterator.coordY = buffer.getFloat(0);</span>
<span class="fc" id="L3871">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using float data type.
         */
<span class="fc" id="L3877">        private class ZfloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="fc" id="L3887">                loaderIterator.coordZ = buffer.getFloat(0);</span>
<span class="fc" id="L3888">            }</span>
        }

        /**
         * Reads x vertex coordinate from temporal buffer using double data
         * type.
         */
<span class="nc" id="L3895">        private class XdoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads x vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3905">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L3907">                loaderIterator.coordX = (float) value;</span>
<span class="nc" id="L3908">            }</span>
        }

        /**
         * Reads y vertex coordinate from temporal buffer using double data
         * type.
         */
<span class="nc" id="L3915">        private class YdoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads y vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3925">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L3927">                loaderIterator.coordY = (float) value;</span>
<span class="nc" id="L3928">            }</span>
        }

        /**
         * Reads z vertex coordinate from temporal buffer using double data
         * type.
         */
<span class="nc" id="L3935">        private class ZdoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads z vertex coordinate from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3945">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L3947">                loaderIterator.coordZ = (float) value;</span>
<span class="nc" id="L3948">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using int8 data type.
         */
<span class="nc" id="L3954">        private class RedInt8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3964">                loaderIterator.red = buffer.get(0);</span>
<span class="nc" id="L3965">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using int8 data
         * type.
         */
<span class="nc" id="L3972">        private class GreenInt8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3982">                loaderIterator.green = buffer.get(0);</span>
<span class="nc" id="L3983">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using int8 data type.
         */
<span class="nc" id="L3989">        private class BlueInt8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L3999">                loaderIterator.blue = buffer.get(0);</span>
<span class="nc" id="L4000">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using int8 data
         * type.
         */
<span class="nc" id="L4007">        private class AlphaInt8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4017">                loaderIterator.alpha = buffer.get(0);</span>
<span class="nc" id="L4018">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using uint8 data type.
         */
<span class="nc" id="L4024">        private class RedUint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4036">                loaderIterator.red = buffer.getShort(0);</span>
<span class="nc" id="L4037">            }</span>
        }

        /**
         * Read green color component from temporal buffer using uint8 data
         * type.
         */
<span class="nc" id="L4044">        private class GreenUint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4056">                loaderIterator.green = buffer.getShort(0);</span>
<span class="nc" id="L4057">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using uint8 data
         * type.
         */
<span class="nc" id="L4064">        private class BlueUint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4076">                loaderIterator.blue = buffer.getShort(0);</span>
<span class="nc" id="L4077">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using uint8 data
         * type.
         */
<span class="nc" id="L4084">        private class AlphaUint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4096">                loaderIterator.alpha = buffer.getShort(0);</span>
<span class="nc" id="L4097">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using int16 data type.
         */
<span class="nc" id="L4103">        private class RedInt16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4113">                loaderIterator.red = buffer.getShort(0);</span>
<span class="nc" id="L4114">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using int16 data
         * type.
         */
<span class="nc" id="L4121">        private class GreenInt16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4131">                loaderIterator.green = buffer.getShort(0);</span>
<span class="nc" id="L4132">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using int16 data
         * type.
         */
<span class="nc" id="L4139">        private class BlueInt16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4149">                loaderIterator.blue = buffer.getShort(0);</span>
<span class="nc" id="L4150">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using int16 data
         * type.
         */
<span class="nc" id="L4157">        private class AlphaInt16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4167">                loaderIterator.alpha = buffer.getShort(0);</span>
<span class="nc" id="L4168">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using uint16 data
         * type.
         */
<span class="nc" id="L4175">        private class RedUint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4187">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4189">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L4190">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using uint16 data
         * type.
         */
<span class="nc" id="L4197">        private class GreenUint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4209">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4211">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L4212">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using uint16 data
         * type.
         */
<span class="nc" id="L4219">        private class BlueUint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4231">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4233">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L4234">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using uint16 data
         * type.
         */
<span class="nc" id="L4241">        private class AlphaUint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4253">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4255">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L4256">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using int32 data type.
         */
<span class="nc" id="L4262">        private class RedInt32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4272">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4274">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L4275">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using int32 data
         * type.
         */
<span class="nc" id="L4282">        private class GreenInt32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4292">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4294">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L4295">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using int32 data
         * type.
         */
<span class="nc" id="L4302">        private class BlueInt32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4312">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4314">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L4315">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using int32 data
         * type.
         */
<span class="nc" id="L4322">        private class AlphaInt32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4332">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4334">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L4335">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using uint32 data
         * type.
         */
<span class="nc" id="L4342">        private class RedUint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4354">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L4356">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L4357">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using uint32 data
         * type.
         */
<span class="nc" id="L4364">        private class GreenUint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4376">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L4378">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L4379">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using uint32 data
         * type.
         */
<span class="nc" id="L4386">        private class BlueUint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4398">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L4400">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L4401">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using uint32 data
         * type.
         */
<span class="nc" id="L4408">        private class AlphaUint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4420">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L4422">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L4423">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using float32 data
         * type.
         */
<span class="nc" id="L4430">        private class RedFloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4440">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L4442">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L4443">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using float32 data
         * type.
         */
<span class="nc" id="L4450">        private class GreenFloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4460">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L4462">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L4463">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using float32 data
         * type.
         */
<span class="nc" id="L4470">        private class BlueFloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4480">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L4482">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L4483">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using float32 data
         * type.
         */
<span class="nc" id="L4490">        private class AlphaFloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4500">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L4502">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L4503">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using float64 data
         * type.
         */
<span class="nc" id="L4510">        private class RedFloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4520">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L4522">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L4523">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using float64 data
         * type.
         */
<span class="nc" id="L4530">        private class GreenFloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4540">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L4542">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L4543">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using float64 data
         * type.
         */
<span class="nc" id="L4550">        private class BlueFloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4560">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L4562">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L4563">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using float64 data
         * type.
         */
<span class="nc" id="L4570">        private class AlphaFloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4580">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L4582">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L4583">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using char data type.
         */
<span class="nc" id="L4589">        private class RedCharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4599">                loaderIterator.red = buffer.get(0);</span>
<span class="nc" id="L4600">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using char data
         * type.
         */
<span class="nc" id="L4607">        private class GreenCharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4617">                loaderIterator.green = buffer.get(0);</span>
<span class="nc" id="L4618">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using char data type.
         */
<span class="nc" id="L4624">        private class BlueCharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4634">                loaderIterator.blue = buffer.get(0);</span>
<span class="nc" id="L4635">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using char data
         * type.
         */
<span class="nc" id="L4642">        private class AlphaCharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4652">                loaderIterator.alpha = buffer.get(0);</span>
<span class="nc" id="L4653">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using uchar data type.
         */
<span class="fc" id="L4659">        private class RedUcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="fc" id="L4671">                loaderIterator.red = buffer.getShort(0);</span>
<span class="fc" id="L4672">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using uchar data
         * type.
         */
<span class="fc" id="L4679">        private class GreenUcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="fc" id="L4691">                loaderIterator.green = buffer.getShort(0);</span>
<span class="fc" id="L4692">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using uchar data
         * type.
         */
<span class="fc" id="L4699">        private class BlueUcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="fc" id="L4711">                loaderIterator.blue = buffer.getShort(0);</span>
<span class="fc" id="L4712">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using uchar data
         * type.
         */
<span class="fc" id="L4719">        private class AlphaUcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="fc" id="L4731">                loaderIterator.alpha = buffer.getShort(0);</span>
<span class="fc" id="L4732">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using short data type.
         */
<span class="nc" id="L4738">        private class RedShortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4748">                loaderIterator.red = buffer.getShort(0);</span>
<span class="nc" id="L4749">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using short data
         * type.
         */
<span class="nc" id="L4756">        private class GreenShortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4766">                loaderIterator.green = buffer.getShort(0);</span>
<span class="nc" id="L4767">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using short data
         * type.
         */
<span class="nc" id="L4774">        private class BlueShortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4784">                loaderIterator.blue = buffer.getShort(0);</span>
<span class="nc" id="L4785">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using short data
         * type.
         */
<span class="nc" id="L4792">        private class AlphaShortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4802">                loaderIterator.alpha = buffer.getShort(0);</span>
<span class="nc" id="L4803">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using ushort data
         * type.
         */
<span class="nc" id="L4810">        private class RedUshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4822">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4824">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L4825">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using ushort data
         * type.
         */
<span class="nc" id="L4832">        private class GreenUshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4844">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4846">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L4847">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using ushort data
         * type.
         */
<span class="nc" id="L4854">        private class BlueUshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4866">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4868">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L4869">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using ushort data
         * type.
         */
<span class="nc" id="L4876">        private class AlphaUshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4888">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4890">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L4891">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using int data type.
         */
<span class="nc" id="L4897">        private class RedIntReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4907">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4909">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L4910">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using int data type.
         */
<span class="nc" id="L4916">        private class GreenIntReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4926">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4928">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L4929">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using int data type.
         */
<span class="nc" id="L4935">        private class BlueIntReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4945">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4947">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L4948">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using int data type.
         */
<span class="nc" id="L4954">        private class AlphaIntReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L4964">                final var value = buffer.getInt(0);</span>

<span class="nc" id="L4966">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L4967">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using uint data type.
         */
<span class="nc" id="L4973">        private class RedUintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L4985">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L4987">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L4988">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using uint data
         * type.
         */
<span class="nc" id="L4995">        private class GreenUintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5007">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L5009">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L5010">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using uint data type.
         */
<span class="nc" id="L5016">        private class BlueUintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5028">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L5030">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L5031">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using uint data
         * type.
         */
<span class="nc" id="L5038">        private class AlphaUintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5050">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L5052">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L5053">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using float data type.
         */
<span class="nc" id="L5059">        private class RedFloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5069">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L5071">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L5072">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using float data
         * type.
         */
<span class="nc" id="L5079">        private class GreenFloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5089">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L5091">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L5092">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using float data
         * type.
         */
<span class="nc" id="L5099">        private class BlueFloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5109">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L5111">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L5112">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using float data
         * type.
         */
<span class="nc" id="L5119">        private class AlphaFloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5129">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L5131">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L5132">            }</span>
        }

        /**
         * Reads red color component from temporal buffer using double data
         * type.
         */
<span class="nc" id="L5139">        private class RedDoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads red color component from temporal buffer and sets its value
             * on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5149">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L5151">                loaderIterator.red = (short) value;</span>
<span class="nc" id="L5152">            }</span>
        }

        /**
         * Reads green color component from temporal buffer using double data
         * type.
         */
<span class="nc" id="L5159">        private class GreenDoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads green color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5169">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L5171">                loaderIterator.green = (short) value;</span>
<span class="nc" id="L5172">            }</span>
        }

        /**
         * Reads blue color component from temporal buffer using double data
         * type.
         */
<span class="nc" id="L5179">        private class BlueDoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads blue color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5189">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L5191">                loaderIterator.blue = (short) value;</span>
<span class="nc" id="L5192">            }</span>
        }

        /**
         * Reads alpha color component from temporal buffer using double data
         * type.
         */
<span class="nc" id="L5199">        private class AlphaDoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads alpha color component from temporal buffer and sets its
             * value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5209">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L5211">                loaderIterator.alpha = (short) value;</span>
<span class="nc" id="L5212">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using int8 type.
         */
<span class="nc" id="L5219">        private class NXint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5229">                loaderIterator.nX = buffer.get(0);</span>
<span class="nc" id="L5230">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using int8 type.
         */
<span class="nc" id="L5237">        private class NYint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5247">                loaderIterator.nY = buffer.get(0);</span>
<span class="nc" id="L5248">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using int8 type.
         */
<span class="nc" id="L5255">        private class NZint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5265">                loaderIterator.nZ = buffer.get(0);</span>
<span class="nc" id="L5266">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using uint8 type.
         */
<span class="nc" id="L5273">        private class NXuint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5285">                loaderIterator.nX = buffer.getShort(0);</span>
<span class="nc" id="L5286">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using uint8 type.
         */
<span class="nc" id="L5293">        private class NYuint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5305">                loaderIterator.nY = buffer.getShort(0);</span>
<span class="nc" id="L5306">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using uint8 type.
         */
<span class="nc" id="L5313">        private class NZuint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5325">                loaderIterator.nZ = buffer.getShort(0);</span>
<span class="nc" id="L5326">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using int16 type.
         */
<span class="nc" id="L5333">        private class NXint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5343">                loaderIterator.nX = buffer.getShort(0);</span>
<span class="nc" id="L5344">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using int16 type.
         */
<span class="nc" id="L5351">        private class NYint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5361">                loaderIterator.nY = buffer.getShort(0);</span>
<span class="nc" id="L5362">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using int16 type.
         */
<span class="nc" id="L5369">        private class NZint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5379">                loaderIterator.nZ = buffer.getShort(0);</span>
<span class="nc" id="L5380">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using uint16 type.
         */
<span class="nc" id="L5387">        private class NXuint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5399">                loaderIterator.nX = buffer.getInt(0);</span>
<span class="nc" id="L5400">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using uint16 type.
         */
<span class="nc" id="L5407">        private class NYuint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5419">                loaderIterator.nY = buffer.getInt(0);</span>
<span class="nc" id="L5420">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using uint16 type.
         */
<span class="nc" id="L5427">        private class NZuint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5439">                loaderIterator.nZ = buffer.getInt(0);</span>
<span class="nc" id="L5440">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using int32 type.
         */
<span class="nc" id="L5447">        private class NXint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5457">                loaderIterator.nX = buffer.getInt(0);</span>
<span class="nc" id="L5458">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using int32 type.
         */
<span class="nc" id="L5465">        private class NYint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5475">                loaderIterator.nY = buffer.getInt(0);</span>
<span class="nc" id="L5476">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using int32 type.
         */
<span class="nc" id="L5483">        private class NZint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5493">                loaderIterator.nZ = buffer.getInt(0);</span>
<span class="nc" id="L5494">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using int32 type.
         */
<span class="nc" id="L5501">        private class NXuint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5513">                loaderIterator.nX = buffer.getLong(0);</span>
<span class="nc" id="L5514">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using uint32 type.
         */
<span class="nc" id="L5521">        private class NYuint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5533">                loaderIterator.nY = buffer.getLong(0);</span>
<span class="nc" id="L5534">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using uint32 type.
         */
<span class="nc" id="L5541">        private class NZuint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5553">                loaderIterator.nZ = buffer.getLong(0);</span>
<span class="nc" id="L5554">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using float32 type.
         */
<span class="nc" id="L5561">        private class NXfloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5571">                loaderIterator.nX = buffer.getFloat(0);</span>
<span class="nc" id="L5572">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using float32 type.
         */
<span class="nc" id="L5579">        private class NYfloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5589">                loaderIterator.nY = buffer.getFloat(0);</span>
<span class="nc" id="L5590">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using float32 type.
         */
<span class="nc" id="L5597">        private class NZfloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5607">                loaderIterator.nZ = buffer.getFloat(0);</span>
<span class="nc" id="L5608">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using float64 type.
         */
<span class="nc" id="L5615">        private class NXfloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5625">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L5627">                loaderIterator.nX = (float) value;</span>
<span class="nc" id="L5628">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using float64 type.
         */
<span class="nc" id="L5635">        private class NYfloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5645">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L5647">                loaderIterator.nY = (float) value;</span>
<span class="nc" id="L5648">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using float64 type.
         */
<span class="nc" id="L5655">        private class NZfloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5665">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L5667">                loaderIterator.nZ = (float) value;</span>
<span class="nc" id="L5668">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using char type.
         */
<span class="nc" id="L5675">        private class NXcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5685">                loaderIterator.nX = buffer.get(0);</span>
<span class="nc" id="L5686">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using char type.
         */
<span class="nc" id="L5693">        private class NYcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5703">                loaderIterator.nY = buffer.get(0);</span>
<span class="nc" id="L5704">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using char type.
         */
<span class="nc" id="L5711">        private class NZcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5721">                loaderIterator.nZ = buffer.get(0);</span>
<span class="nc" id="L5722">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using uchar type.
         */
<span class="nc" id="L5729">        private class NXucharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5741">                loaderIterator.nX = buffer.getShort(0);</span>
<span class="nc" id="L5742">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using uchar type.
         */
<span class="nc" id="L5749">        private class NYucharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5761">                loaderIterator.nY = buffer.getShort(0);</span>
<span class="nc" id="L5762">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using uchar type.
         */
<span class="nc" id="L5769">        private class NZucharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5781">                loaderIterator.nZ = buffer.getShort(0);</span>
<span class="nc" id="L5782">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using short type.
         */
<span class="nc" id="L5789">        private class NXshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5799">                loaderIterator.nX = buffer.getShort(0);</span>
<span class="nc" id="L5800">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using short type.
         */
<span class="nc" id="L5807">        private class NYshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5817">                loaderIterator.nY = buffer.getShort(0);</span>
<span class="nc" id="L5818">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using short type.
         */
<span class="nc" id="L5825">        private class NZshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5835">                loaderIterator.nZ = buffer.getShort(0);</span>
<span class="nc" id="L5836">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using ushort type.
         */
<span class="nc" id="L5843">        private class NXushortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5855">                loaderIterator.nX = buffer.getInt(0);</span>
<span class="nc" id="L5856">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using ushort type.
         */
<span class="nc" id="L5863">        private class NYushortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5875">                loaderIterator.nY = buffer.getInt(0);</span>
<span class="nc" id="L5876">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using ushort type.
         */
<span class="nc" id="L5883">        private class NZushortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5895">                loaderIterator.nZ = buffer.getInt(0);</span>
<span class="nc" id="L5896">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using int type.
         */
<span class="nc" id="L5903">        private class NXintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5913">                loaderIterator.nX = buffer.getInt(0);</span>
<span class="nc" id="L5914">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using int type.
         */
<span class="nc" id="L5921">        private class NYintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5931">                loaderIterator.nY = buffer.getInt(0);</span>
<span class="nc" id="L5932">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using int type.
         */
<span class="nc" id="L5939">        private class NZintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L5949">                loaderIterator.nZ = buffer.getInt(0);</span>
<span class="nc" id="L5950">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using uint type.
         */
<span class="nc" id="L5957">        private class NXuintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5969">                loaderIterator.nX = buffer.getLong(0);</span>
<span class="nc" id="L5970">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using uint type.
         */
<span class="nc" id="L5977">        private class NYuintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L5989">                loaderIterator.nY = buffer.getLong(0);</span>
<span class="nc" id="L5990">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using uint type.
         */
<span class="nc" id="L5997">        private class NZuintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L6009">                loaderIterator.nZ = buffer.getLong(0);</span>
<span class="nc" id="L6010">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component form temporal buffer
         * using float type.
         */
<span class="fc" id="L6017">        private class NXfloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="fc" id="L6027">                loaderIterator.nX = buffer.getFloat(0);</span>
<span class="fc" id="L6028">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using float type.
         */
<span class="fc" id="L6035">        private class NYfloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="fc" id="L6045">                loaderIterator.nY = buffer.getFloat(0);</span>
<span class="fc" id="L6046">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using float type.
         */
<span class="fc" id="L6053">        private class NZfloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="fc" id="L6063">                loaderIterator.nZ = buffer.getFloat(0);</span>
<span class="fc" id="L6064">            }</span>
        }

        /**
         * Reads a vertex normal x coordinate component from temporal buffer
         * using double type.
         */
<span class="nc" id="L6071">        private class NXdoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal x coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6081">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L6083">                loaderIterator.nX = (float) value;</span>
<span class="nc" id="L6084">            }</span>
        }

        /**
         * Reads a vertex normal y coordinate component from temporal buffer
         * using double type.
         */
<span class="nc" id="L6091">        private class NYdoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal y coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6101">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L6103">                loaderIterator.nY = (float) value;</span>
<span class="nc" id="L6104">            }</span>
        }

        /**
         * Reads a vertex normal z coordinate component from temporal buffer
         * using double type.
         */
<span class="nc" id="L6111">        private class NZdoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads a vertex normal z coordinate from temporal buffer and sets
             * its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6121">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L6123">                loaderIterator.nZ = (float) value;</span>
<span class="nc" id="L6124">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * int8 type.
         */
<span class="nc" id="L6131">        private class FaceInt8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6141">                loaderIterator.index = buffer.get(0);</span>
<span class="nc" id="L6142">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * uint8 type.
         */
<span class="nc" id="L6149">        private class FaceUint8ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L6161">                loaderIterator.index = buffer.getShort(0);</span>
<span class="nc" id="L6162">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * int16 type.
         */
<span class="nc" id="L6169">        private class FaceInt16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6179">                loaderIterator.index = buffer.getShort(0);</span>
<span class="nc" id="L6180">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * uint16 type.
         */
<span class="nc" id="L6187">        private class FaceUint16ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L6199">                loaderIterator.index = buffer.getInt(0);</span>
<span class="nc" id="L6200">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * int32 type.
         */
<span class="nc" id="L6207">        private class FaceInt32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6217">                loaderIterator.index = buffer.getInt(0);</span>
<span class="nc" id="L6218">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * uint32 type.
         */
<span class="nc" id="L6225">        private class FaceUint32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L6237">                loaderIterator.index = buffer.getLong(0);</span>
<span class="nc" id="L6238">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * float32 type.
         */
<span class="nc" id="L6245">        private class FaceFloat32ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6255">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L6257">                loaderIterator.index = (long) value;</span>
<span class="nc" id="L6258">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * float64 type.
         */
<span class="nc" id="L6265">        private class FaceFloat64ReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6275">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L6277">                loaderIterator.index = (long) value;</span>
<span class="nc" id="L6278">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * char type.
         */
<span class="nc" id="L6285">        private class FaceCharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6295">                loaderIterator.index = buffer.get(0);</span>
<span class="nc" id="L6296">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * uchar type.
         */
<span class="nc" id="L6303">        private class FaceUcharReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L6315">                loaderIterator.index = buffer.getShort(0);</span>
<span class="nc" id="L6316">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * short type.
         */
<span class="nc" id="L6323">        private class FaceShortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6333">                loaderIterator.index = buffer.getShort(0);</span>
<span class="nc" id="L6334">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * ushort type.
         */
<span class="nc" id="L6341">        private class FaceUshortReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L6353">                loaderIterator.index = buffer.getInt(0);</span>
<span class="nc" id="L6354">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * int type.
         */
<span class="fc" id="L6361">        private class FaceIntReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="fc" id="L6371">                loaderIterator.index = buffer.getInt(0);</span>
<span class="fc" id="L6372">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * uint type.
         */
<span class="nc" id="L6379">        private class FaceUintReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // because java doesn't support unsigned types we use the next
                // type that can hold all desired values
<span class="nc" id="L6391">                loaderIterator.index = buffer.getLong(0);</span>
<span class="nc" id="L6392">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * float type.
         */
<span class="nc" id="L6399">        private class FaceFloatReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6409">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L6411">                loaderIterator.index = (long) value;</span>
<span class="nc" id="L6412">            }</span>
        }

        /**
         * Reads the index of a face/polygon vertex from temporal buffer using
         * double type.
         */
<span class="nc" id="L6419">        private class FaceDoubleReadValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads the index of a face/polygon vertex from temporal buffer and
             * sets its value on current loader iterator.
             *
             * @param buffer Temporal buffer.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L6429">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L6431">                loaderIterator.index = (long) value;</span>
<span class="nc" id="L6432">            }</span>
        }

        /**
         * Reads an int8 from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6439">        private class AsciiInt8ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into an int8 value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an int8.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6455">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6457" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="nc" id="L6461">                    final var value = Byte.parseByte(str);</span>

                    // save to buffer
<span class="nc" id="L6464">                    buffer.put(0, value);</span>
<span class="nc" id="L6465">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6466">                    throw new IOException(e);</span>
<span class="nc" id="L6467">                }</span>
<span class="nc" id="L6468">            }</span>
        }

        /**
         * Reads a uint8 from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6475">        private class AsciiUint8ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into an uint8 value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an uint8.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6491">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6493" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // Because Java doesn't support unsigned types we use the next type
                // capable of holding all values
                try {
<span class="nc" id="L6498">                    final var value = Short.parseShort(str);</span>

                    // save to buffer
<span class="nc" id="L6501">                    buffer.putShort(0, value);</span>
<span class="nc" id="L6502">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6503">                    throw new IOException(e);</span>
<span class="nc" id="L6504">                }</span>
<span class="nc" id="L6505">            }</span>
        }

        /**
         * Reads an int16 from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6512">        private class AsciiInt16ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into an int16 value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an int16.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6528">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6530" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="nc" id="L6534">                    final var value = Short.parseShort(str);</span>

                    // save to buffer
<span class="nc" id="L6537">                    buffer.putShort(0, value);</span>
<span class="nc" id="L6538">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6539">                    throw new IOException(e);</span>
<span class="nc" id="L6540">                }</span>
<span class="nc" id="L6541">            }</span>
        }

        /**
         * Reads a uint16 from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6548">        private class AsciiUint16ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into an uint16 value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an uint16.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6564">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6566" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // Because Java doesn't support unsigned types we use the next type
                // capable of holding all values
                try {
<span class="nc" id="L6571">                    final var value = Integer.parseInt(str);</span>

                    // save to buffer
<span class="nc" id="L6574">                    buffer.putInt(0, value);</span>
<span class="nc" id="L6575">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6576">                    throw new IOException(e);</span>
<span class="nc" id="L6577">                }</span>
<span class="nc" id="L6578">            }</span>
        }

        /**
         * Reads an int32 from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6585">        private class AsciiInt32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into an int32 value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an int32.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6601">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6603" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="nc" id="L6607">                    final var value = Integer.parseInt(str);</span>

                    // save to buffer
<span class="nc" id="L6610">                    buffer.putInt(0, value);</span>
<span class="nc" id="L6611">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6612">                    throw new IOException(e);</span>
<span class="nc" id="L6613">                }</span>
<span class="nc" id="L6614">            }</span>
        }

        /**
         * Reads a uint32 from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6621">        private class AsciiUint32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into an uint32 value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an uint32.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6637">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6639" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // Because Java doesn't support unsigned types we use the next type
                // capable of holding all values
                try {
<span class="nc" id="L6644">                    final var value = Long.parseLong(str);</span>

                    // save to buffer
<span class="nc" id="L6647">                    buffer.putLong(0, value);</span>
<span class="nc" id="L6648">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6649">                    throw new IOException(e);</span>
<span class="nc" id="L6650">                }</span>
<span class="nc" id="L6651">            }</span>
        }

        /**
         * Reads a float32 from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6658">        private class AsciiFloat32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a float32 value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an float32.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6674">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6676" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="nc" id="L6680">                    final var value = Float.parseFloat(str);</span>

                    // save to buffer
<span class="nc" id="L6683">                    buffer.putFloat(0, value);</span>
<span class="nc" id="L6684">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6685">                    throw new IOException(e);</span>
<span class="nc" id="L6686">                }</span>
<span class="nc" id="L6687">            }</span>
        }

        /**
         * Reads a float64 from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6694">        private class AsciiFloat64ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a float64 value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an float64.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6710">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6712" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="nc" id="L6716">                    final var value = Double.parseDouble(str);</span>

                    // save to buffer
<span class="nc" id="L6719">                    buffer.putDouble(0, value);</span>
<span class="nc" id="L6720">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6721">                    throw new IOException(e);</span>
<span class="nc" id="L6722">                }</span>
<span class="nc" id="L6723">            }</span>
        }

        /**
         * Reads a char from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6730">        private class AsciiCharReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a char value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into a char.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6746">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6748" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="nc" id="L6752">                    final var value = Byte.parseByte(str);</span>

                    // save to buffer
<span class="nc" id="L6755">                    buffer.put(0, value);</span>
<span class="nc" id="L6756">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6757">                    throw new IOException(e);</span>
<span class="nc" id="L6758">                }</span>
<span class="nc" id="L6759">            }</span>
        }

        /**
         * Reads a uchar from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="fc" id="L6766">        private class AsciiUcharReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a uchar value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into a uchar.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="fc" id="L6782">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="pc bpc" id="L6784" title="1 of 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // Because Java doesn't support unsigned types we use the next type
                // capable of holding all values
                try {
<span class="fc" id="L6789">                    final var value = Short.parseShort(str);</span>

                    // save to buffer
<span class="fc" id="L6792">                    buffer.putShort(0, value);</span>
<span class="nc" id="L6793">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6794">                    throw new IOException(e);</span>
<span class="fc" id="L6795">                }</span>
<span class="fc" id="L6796">            }</span>
        }

        /**
         * Reads a short from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6803">        private class AsciiShortReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a short value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into a short.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6819">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6821" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="nc" id="L6825">                    final var value = Short.parseShort(str);</span>

                    // save to buffer
<span class="nc" id="L6828">                    buffer.putShort(0, value);</span>
<span class="nc" id="L6829">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6830">                    throw new IOException(e);</span>
<span class="nc" id="L6831">                }</span>
<span class="nc" id="L6832">            }</span>
        }

        /**
         * Reads a ushort from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6839">        private class AsciiUshortReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a ushort value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into a ushort.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6855">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6857" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // Because Java doesn't support unsigned types we use the next type
                // capable of holding all values
                try {
<span class="nc" id="L6862">                    final var value = Integer.parseInt(str);</span>

                    // save to buffer
<span class="nc" id="L6865">                    buffer.putInt(0, value);</span>
<span class="nc" id="L6866">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6867">                    throw new IOException(e);</span>
<span class="nc" id="L6868">                }</span>
<span class="nc" id="L6869">            }</span>
        }

        /**
         * Reads an int from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="fc" id="L6876">        private class AsciiIntReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into an int value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into an int.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="fc" id="L6892">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="pc bpc" id="L6894" title="3 of 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="fc" id="L6898">                    final var value = Integer.parseInt(str);</span>

                    // save to buffer
<span class="fc" id="L6901">                    buffer.putInt(0, value);</span>
<span class="nc" id="L6902">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6903">                    throw new IOException(e);</span>
<span class="fc" id="L6904">                }</span>
<span class="fc" id="L6905">            }</span>
        }

        /**
         * Reads a uint from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6912">        private class AsciiUintReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a uint value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into a uint.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L6928">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L6930" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // Because Java doesn't support unsigned types we use the next type
                // capable of holding all values
                try {
<span class="nc" id="L6935">                    final var value = Long.parseLong(str);</span>

                    // save to buffer
<span class="nc" id="L6938">                    buffer.putLong(0, value);</span>
<span class="nc" id="L6939">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6940">                    throw new IOException(e);</span>
<span class="nc" id="L6941">                }</span>
<span class="nc" id="L6942">            }</span>
        }

        /**
         * Reads a float from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="fc" id="L6949">        private class AsciiFloatReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a float value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into a float.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="fc" id="L6965">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="pc bpc" id="L6967" title="1 of 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="fc" id="L6971">                    final var value = Float.parseFloat(str);</span>

                    // save to buffer
<span class="fc" id="L6974">                    buffer.putFloat(0, value);</span>
<span class="nc" id="L6975">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L6976">                    throw new IOException(e);</span>
<span class="fc" id="L6977">                }</span>
<span class="fc" id="L6978">            }</span>
        }

        /**
         * Reads a double from the file stream of data assuming that file is in
         * ascii text format.
         */
<span class="nc" id="L6985">        private class AsciiDoubleReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads next word of text within file at current position and
             * attempts to parse it into a double value.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs or data cannot be
             *                     parsed into a double.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                String str;

                // read word
                do {
<span class="nc" id="L7001">                    str = reader.readWord();</span>
                    // loop to avoid empty strings
<span class="nc bnc" id="L7003" title="All 4 branches missed.">                } while ((str.isEmpty()) &amp;&amp; !reader.isEndOfStream());</span>

                // retrieve word value
                try {
<span class="nc" id="L7007">                    final var value = Double.parseDouble(str);</span>

                    // save to buffer
<span class="nc" id="L7010">                    buffer.putDouble(0, value);</span>
<span class="nc" id="L7011">                } catch (final NumberFormatException e) {</span>
<span class="nc" id="L7012">                    throw new IOException(e);</span>
<span class="nc" id="L7013">                }</span>
<span class="nc" id="L7014">            }</span>
        }

        /**
         * Reads an int8 from the file stream of data assuming that file is in
         * binary format.
         */
<span class="nc" id="L7021">        private class BinaryInt8ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads an int8 from the stream of data at current file position
             * and stores the result into provided byte buffer.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7032">                final var value = reader.readByte();</span>

                // save to buffer
<span class="nc" id="L7035">                buffer.put(0, value);</span>
<span class="nc" id="L7036">            }</span>
        }

        /**
         * Reads a uint8 from the file stream of data assuming that file is in
         * binary format.
         */
<span class="nc" id="L7043">        private class BinaryUint8ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a uint8 from the stream of data at current file position
             * and stores the result into provided byte buffer.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7056">                final var value = reader.readUnsignedByte();</span>

                // save to buffer
<span class="nc" id="L7059">                buffer.putShort(0, value);</span>
<span class="nc" id="L7060">            }</span>
        }

        /**
         * Reads a char from the file stream of data assuming that file is in
         * binary format.
         */
<span class="nc" id="L7067">        private class BinaryCharReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a char from the stream of data at current file position
             * and stores the result into provided byte buffer.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7078">                final var value = reader.readByte();</span>

                // save to buffer
<span class="nc" id="L7081">                buffer.put(0, value);</span>
<span class="nc" id="L7082">            }</span>
        }

        /**
         * Reads a uchar from the file stream of data assuming that file is in
         * binary format.
         */
<span class="fc" id="L7089">        private class BinaryUcharReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a uchar from the stream of data at current file position
             * and stores the result into provided byte buffer.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="fc" id="L7102">                final var value = reader.readUnsignedByte();</span>

                // save to buffer
<span class="fc" id="L7105">                buffer.putShort(0, value);</span>
<span class="fc" id="L7106">            }</span>
        }

        /**
         * Reads an int16 from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7113">        private class BinaryLittleEndianInt16ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads an int16 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7125">                final var value = reader.readShort(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7128">                buffer.putShort(0, value);</span>
<span class="nc" id="L7129">            }</span>
        }

        /**
         * Reads a uint16 from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7136">        private class BinaryLittleEndianUint16ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a uint16 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7150">                final var value = reader.readUnsignedShort(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7153">                buffer.putInt(0, value);</span>
<span class="nc" id="L7154">            }</span>
        }

        /**
         * Reads an int32 from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7161">        private class BinaryLittleEndianInt32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads an int32 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7173">                final var value = reader.readInt(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7176">                buffer.putInt(0, value);</span>
<span class="nc" id="L7177">            }</span>
        }

        /**
         * Reads a uint32 from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7184">        private class BinaryLittleEndianUint32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a uint32 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7198">                final var value = reader.readUnsignedInt(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7201">                buffer.putLong(0, value);</span>
<span class="nc" id="L7202">            }</span>
        }

        /**
         * Reads a float32 from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7209">        private class BinaryLittleEndianFloat32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a float32 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7221">                final var value = reader.readFloat(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7224">                buffer.putFloat(0, value);</span>
<span class="nc" id="L7225">            }</span>
        }

        /**
         * Reads a float64 from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7232">        private class BinaryLittleEndianFloat64ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a float64 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7244">                final var value = reader.readDouble(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7247">                buffer.putDouble(0, value);</span>
<span class="nc" id="L7248">            }</span>
        }

        /**
         * Reads a short from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7255">        private class BinaryLittleEndianShortReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a short from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7267">                final var value = reader.readShort(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7270">                buffer.putShort(0, value);</span>
<span class="nc" id="L7271">            }</span>
        }

        /**
         * Reads a ushort from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7278">        private class BinaryLittleEndianUshortReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a ushort from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7292">                final var value = reader.readUnsignedShort(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7295">                buffer.putInt(0, value);</span>
<span class="nc" id="L7296">            }</span>
        }

        /**
         * Reads an int from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="fc" id="L7303">        private class BinaryLittleEndianIntReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads an int from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="fc" id="L7315">                final var value = reader.readInt(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="fc" id="L7318">                buffer.putInt(0, value);</span>
<span class="fc" id="L7319">            }</span>
        }

        /**
         * Reads a uint from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7326">        private class BinaryLittleEndianUintReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a uint from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7340">                final var value = reader.readUnsignedInt(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7343">                buffer.putLong(0, value);</span>
<span class="nc" id="L7344">            }</span>
        }

        /**
         * Reads a float from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="fc" id="L7351">        private class BinaryLittleEndianFloatReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a float from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="fc" id="L7363">                final var value = reader.readFloat(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="fc" id="L7366">                buffer.putFloat(0, value);</span>
<span class="fc" id="L7367">            }</span>
        }

        /**
         * Reads a double from the file stream of data assuming that file is in
         * little endian binary format.
         */
<span class="nc" id="L7374">        private class BinaryLittleEndianDoubleReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a double from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in little endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7386">                final var value = reader.readDouble(EndianType.LITTLE_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7389">                buffer.putDouble(0, value);</span>
<span class="nc" id="L7390">            }</span>
        }

        /**
         * Reads an int16 from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7397">        private class BinaryBigEndianInt16ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads an int16 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7409">                final var value = reader.readShort(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7412">                buffer.putShort(0, value);</span>
<span class="nc" id="L7413">            }</span>
        }

        /**
         * Reads a uint16 from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7420">        private class BinaryBigEndianUint16ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a uint16 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7434">                final var value = reader.readUnsignedShort(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7437">                buffer.putInt(0, value);</span>
<span class="nc" id="L7438">            }</span>
        }

        /**
         * Reads an int32 from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7445">        private class BinaryBigEndianInt32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads an int32 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7457">                final var value = reader.readInt(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7460">                buffer.putInt(0, value);</span>
<span class="nc" id="L7461">            }</span>
        }

        /**
         * Reads a uint32 from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7468">        private class BinaryBigEndianUint32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a uint32 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7482">                final var value = reader.readUnsignedInt(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7485">                buffer.putLong(0, value);</span>
<span class="nc" id="L7486">            }</span>
        }

        /**
         * Reads a float32 from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7493">        private class BinaryBigEndianFloat32ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a float32 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7505">                final var value = reader.readFloat(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7508">                buffer.putFloat(0, value);</span>
<span class="nc" id="L7509">            }</span>
        }

        /**
         * Reads a float64 from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7516">        private class BinaryBigEndianFloat64ReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a float64 from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7528">                final var value = reader.readDouble(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7531">                buffer.putDouble(0, value);</span>
<span class="nc" id="L7532">            }</span>
        }

        /**
         * Reads a short from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7539">        private class BinaryBigEndianShortReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a short from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7551">                final var value = reader.readShort(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7554">                buffer.putShort(0, value);</span>
<span class="nc" id="L7555">            }</span>
        }

        /**
         * Reads a ushort from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7562">        private class BinaryBigEndianUshortReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a ushort from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7576">                final var value = reader.readUnsignedShort(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7579">                buffer.putInt(0, value);</span>
<span class="nc" id="L7580">            }</span>
        }

        /**
         * Reads an int from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="fc" id="L7587">        private class BinaryBigEndianIntReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads an int from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="fc" id="L7599">                final var value = reader.readInt(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="fc" id="L7602">                buffer.putInt(0, value);</span>
<span class="fc" id="L7603">            }</span>
        }

        /**
         * Reads a uint from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7610">        private class BinaryBigEndianUintReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a uint from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
                // Because Java doesn't support unsigned types, we use the next
                // type that can hold all values
<span class="nc" id="L7624">                final var value = reader.readUnsignedInt(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7627">                buffer.putLong(0, value);</span>
<span class="nc" id="L7628">            }</span>
        }

        /**
         * Reads a float from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="fc" id="L7635">        private class BinaryBigEndianFloatReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a float from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="fc" id="L7647">                final var value = reader.readFloat(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="fc" id="L7650">                buffer.putFloat(0, value);</span>
<span class="fc" id="L7651">            }</span>
        }

        /**
         * Reads a double from the file stream of data assuming that file is in
         * big endian binary format.
         */
<span class="nc" id="L7658">        private class BinaryBigEndianDoubleReadValueFromStreamListener implements PLYReadValueFromStreamListener {</span>

            /**
             * Reads a double from the stream of data at current file position
             * and stores the result into provided byte buffer. Stream data is
             * assumed to be in big endian format.
             *
             * @param buffer Buffer where data will be stored.
             * @throws IOException if an I/O error occurs.
             */
            @Override
            public void readFromStream(final ByteBuffer buffer) throws IOException {
<span class="nc" id="L7670">                final var value = reader.readDouble(EndianType.BIG_ENDIAN_TYPE);</span>

                // save to buffer
<span class="nc" id="L7673">                buffer.putDouble(0, value);</span>
<span class="nc" id="L7674">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has int8 data type.
         */
<span class="nc" id="L7681">        private class FaceInt8ReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has int8 data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7692">                loaderIterator.listElems = buffer.get(0);</span>
<span class="nc" id="L7693">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has uint8 data type.
         */
<span class="nc" id="L7700">        private class FaceUint8ReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has uint8 data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // Because Jave doesn't support unsigned types, we use next
                // type capable of holding all values
<span class="nc" id="L7713">                loaderIterator.listElems = buffer.getShort(0);</span>
<span class="nc" id="L7714">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has int16 data type.
         */
<span class="nc" id="L7721">        private class FaceInt16ReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has int16 data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7732">                loaderIterator.listElems = buffer.getShort(0);</span>
<span class="nc" id="L7733">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has uint16 data type.
         */
<span class="nc" id="L7740">        private class FaceUint16ReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has uint16 data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // Because Jave doesn't support unsigned types, we use next
                // type capable of holding all values
<span class="nc" id="L7753">                loaderIterator.listElems = buffer.getInt(0);</span>
<span class="nc" id="L7754">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has int32 data type.
         */
<span class="nc" id="L7761">        private class FaceInt32ReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has int32 data type. Value read from buffer
             * will be stored into this PLY loader iterator
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7772">                loaderIterator.listElems = buffer.getInt(0);</span>
<span class="nc" id="L7773">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has uint32 data type.
         */
<span class="nc" id="L7780">        private class FaceUint32ReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has uint32 data type. Value read from buffer
             * will be stored into this PLY loader iterator
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // Because Jave doesn't support unsigned types, we use next
                // type capable of holding all values
<span class="nc" id="L7793">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L7795">                loaderIterator.listElems = (int) value;</span>
<span class="nc" id="L7796">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has float32 data type.
         */
<span class="nc" id="L7803">        private class FaceFloat32ReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has float32 data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7814">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L7816">                loaderIterator.listElems = (int) value;</span>
<span class="nc" id="L7817">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has float64 data type.
         */
<span class="nc" id="L7824">        private class FaceFloat64ReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has float64 data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7835">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L7837">                loaderIterator.listElems = (int) value;</span>
<span class="nc" id="L7838">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has char data type.
         */
<span class="nc" id="L7845">        private class FaceCharReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has char data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7856">                loaderIterator.listElems = buffer.get(0);</span>
<span class="nc" id="L7857">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has uchar data type.
         */
<span class="fc" id="L7864">        private class FaceUcharReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has uchar data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // Because Jave doesn't support unsigned types, we use next
                // type capable of holding all values
<span class="fc" id="L7877">                loaderIterator.listElems = buffer.getShort(0);</span>
<span class="fc" id="L7878">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has short data type.
         */
<span class="nc" id="L7885">        private class FaceShortReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has short data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7896">                loaderIterator.listElems = buffer.getShort(0);</span>
<span class="nc" id="L7897">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has ushort data type.
         */
<span class="nc" id="L7904">        private class FaceUshortReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has ushort data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // Because Jave doesn't support unsigned types, we use next
                // type capable of holding all values
<span class="nc" id="L7917">                loaderIterator.listElems = buffer.getInt(0);</span>
<span class="nc" id="L7918">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has int data type.
         */
<span class="nc" id="L7925">        private class FaceIntReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has int data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7936">                loaderIterator.listElems = buffer.getInt(0);</span>
<span class="nc" id="L7937">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has uint data type.
         */
<span class="nc" id="L7944">        private class FaceUintReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has uint data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
                // Because Jave doesn't support unsigned types, we use next
                // type capable of holding all values
<span class="nc" id="L7957">                final var value = buffer.getLong(0);</span>

<span class="nc" id="L7959">                loaderIterator.listElems = (int) value;</span>
<span class="nc" id="L7960">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has float data type.
         */
<span class="nc" id="L7967">        private class FaceFloatReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has float data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7978">                final var value = buffer.getFloat(0);</span>

<span class="nc" id="L7980">                loaderIterator.listElems = (int) value;</span>
<span class="nc" id="L7981">            }</span>
        }

        /**
         * Reads length value of a list header element from temporal buffer of
         * data assuming it has double data type.
         */
<span class="nc" id="L7988">        private class FaceDoubleReadLengthValueFromBufferListener implements PLYReadValueFromBufferListener {</span>

            /**
             * Reads length value of a list header element from temporal buffer
             * of data assuming it has double data type. Value read from buffer
             * will be stored into this PLY loader iterator.
             *
             * @param buffer Temporal buffer of data.
             */
            @Override
            public void readValueFromBuffer(final ByteBuffer buffer) {
<span class="nc" id="L7999">                final var value = buffer.getDouble(0);</span>

<span class="nc" id="L8001">                loaderIterator.listElems = (int) value;</span>
<span class="nc" id="L8002">            }</span>
        }

        /**
         * Sets the listener to read data from the file stream for a given
         * PLY header property and using provided storage mode.
         *
         * @param property    A PLY header property.
         * @param storageMode Storage mode of file.
         * @throws NotAvailableException Raised if the listener cannot be set
         *                               for provided property and storage mode.
         */
        private void setReadValueFromStreamListener(final PropertyPLY property, final PLYStorageMode storageMode)
                throws NotAvailableException {
<span class="fc" id="L8016">            property.setReadValueFromStreamListener(getReadFromStreamListener(property.getValueType(), storageMode));</span>
<span class="fc" id="L8017">        }</span>

        /**
         * Sets the listener to read length value of a property from the file
         * stream for a given PLY header property and using provided storage
         * mode.
         *
         * @param property    A PLY header property.
         * @param storageMode Storage mode of file.
         * @throws NotAvailableException Raised if the listener cannot be set
         *                               for provided property and storage mode.
         */
        private void setReadLengthValueFromStreamListener(
                final PropertyPLY property, final PLYStorageMode storageMode) throws NotAvailableException {
<span class="fc" id="L8031">            property.setReadLengthValueFromStreamListener(</span>
<span class="fc" id="L8032">                    getReadFromStreamListener(property.getLengthType(), storageMode));</span>
<span class="fc" id="L8033">        }</span>

        /**
         * Returns a listener to read data from the file stream using provided
         * data type (int8, uint8, int16, uint16, etc.) and storage mode (ascii,
         * little endian or big endian).
         *
         * @param dataType    Data type to read.
         * @param storageMode Storage mode of file.
         * @return A listener.
         */
        private PLYReadValueFromStreamListener getReadFromStreamListener(
                final DataTypePLY dataType, final PLYStorageMode storageMode) {
<span class="pc bpc" id="L8046" title="13 of 16 branches missed.">            return switch (dataType) {</span>
<span class="nc bnc" id="L8047" title="All 2 branches missed.">                case PLY_INT8 -&gt; switch (storageMode) {</span>
<span class="nc" id="L8048">                    case PLY_ASCII -&gt; new AsciiInt8ReadValueFromStreamListener();</span>
<span class="nc" id="L8049">                    case PLY_LITTLE_ENDIAN, PLY_BIG_ENDIAN -&gt; new BinaryInt8ReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8051" title="All 2 branches missed.">                case PLY_UINT8 -&gt; switch (storageMode) {</span>
<span class="nc" id="L8052">                    case PLY_ASCII -&gt; new AsciiUint8ReadValueFromStreamListener();</span>
<span class="nc" id="L8053">                    case PLY_LITTLE_ENDIAN, PLY_BIG_ENDIAN -&gt; new BinaryUint8ReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8055" title="All 3 branches missed.">                case PLY_INT16 -&gt; switch (storageMode) {</span>
<span class="nc" id="L8056">                    case PLY_ASCII -&gt; new AsciiInt16ReadValueFromStreamListener();</span>
<span class="nc" id="L8057">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianInt16ReadValueFromStreamListener();</span>
<span class="nc" id="L8058">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianInt16ReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8060" title="All 3 branches missed.">                case PLY_UINT16 -&gt; switch (storageMode) {</span>
<span class="nc" id="L8061">                    case PLY_ASCII -&gt; new AsciiUint16ReadValueFromStreamListener();</span>
<span class="nc" id="L8062">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianUint16ReadValueFromStreamListener();</span>
<span class="nc" id="L8063">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianUint16ReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8065" title="All 3 branches missed.">                case PLY_INT32 -&gt; switch (storageMode) {</span>
<span class="nc" id="L8066">                    case PLY_ASCII -&gt; new AsciiInt32ReadValueFromStreamListener();</span>
<span class="nc" id="L8067">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianInt32ReadValueFromStreamListener();</span>
<span class="nc" id="L8068">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianInt32ReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8070" title="All 3 branches missed.">                case PLY_UINT32 -&gt; switch (storageMode) {</span>
<span class="nc" id="L8071">                    case PLY_ASCII -&gt; new AsciiUint32ReadValueFromStreamListener();</span>
<span class="nc" id="L8072">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianUint32ReadValueFromStreamListener();</span>
<span class="nc" id="L8073">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianUint32ReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8075" title="All 3 branches missed.">                case PLY_FLOAT32 -&gt; switch (storageMode) {</span>
<span class="nc" id="L8076">                    case PLY_ASCII -&gt; new AsciiFloat32ReadValueFromStreamListener();</span>
<span class="nc" id="L8077">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianFloat32ReadValueFromStreamListener();</span>
<span class="nc" id="L8078">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianFloat32ReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8080" title="All 3 branches missed.">                case PLY_FLOAT64 -&gt; switch (storageMode) {</span>
<span class="nc" id="L8081">                    case PLY_ASCII -&gt; new AsciiFloat64ReadValueFromStreamListener();</span>
<span class="nc" id="L8082">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianFloat64ReadValueFromStreamListener();</span>
<span class="nc" id="L8083">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianFloat64ReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8085" title="All 2 branches missed.">                case PLY_CHAR -&gt; switch (storageMode) {</span>
<span class="nc" id="L8086">                    case PLY_ASCII -&gt; new AsciiCharReadValueFromStreamListener();</span>
<span class="nc" id="L8087">                    case PLY_LITTLE_ENDIAN, PLY_BIG_ENDIAN -&gt; new BinaryCharReadValueFromStreamListener();</span>
                };
<span class="fc bfc" id="L8089" title="All 2 branches covered.">                case PLY_UCHAR -&gt; switch (storageMode) {</span>
<span class="fc" id="L8090">                    case PLY_ASCII -&gt; new AsciiUcharReadValueFromStreamListener();</span>
<span class="fc" id="L8091">                    case PLY_LITTLE_ENDIAN, PLY_BIG_ENDIAN -&gt; new BinaryUcharReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8093" title="All 3 branches missed.">                case PLY_SHORT -&gt; switch (storageMode) {</span>
<span class="nc" id="L8094">                    case PLY_ASCII -&gt; new AsciiShortReadValueFromStreamListener();</span>
<span class="nc" id="L8095">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianShortReadValueFromStreamListener();</span>
<span class="nc" id="L8096">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianShortReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8098" title="All 3 branches missed.">                case PLY_USHORT -&gt; switch (storageMode) {</span>
<span class="nc" id="L8099">                    case PLY_ASCII -&gt; new AsciiUshortReadValueFromStreamListener();</span>
<span class="nc" id="L8100">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianUshortReadValueFromStreamListener();</span>
<span class="nc" id="L8101">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianUshortReadValueFromStreamListener();</span>
                };
<span class="fc bfc" id="L8103" title="All 3 branches covered.">                case PLY_INT -&gt; switch (storageMode) {</span>
<span class="fc" id="L8104">                    case PLY_ASCII -&gt; new AsciiIntReadValueFromStreamListener();</span>
<span class="fc" id="L8105">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianIntReadValueFromStreamListener();</span>
<span class="fc" id="L8106">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianIntReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8108" title="All 3 branches missed.">                case PLY_UINT -&gt; switch (storageMode) {</span>
<span class="nc" id="L8109">                    case PLY_ASCII -&gt; new AsciiUintReadValueFromStreamListener();</span>
<span class="nc" id="L8110">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianUintReadValueFromStreamListener();</span>
<span class="nc" id="L8111">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianUintReadValueFromStreamListener();</span>
                };
<span class="fc bfc" id="L8113" title="All 3 branches covered.">                case PLY_FLOAT -&gt; switch (storageMode) {</span>
<span class="fc" id="L8114">                    case PLY_ASCII -&gt; new AsciiFloatReadValueFromStreamListener();</span>
<span class="fc" id="L8115">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianFloatReadValueFromStreamListener();</span>
<span class="fc" id="L8116">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianFloatReadValueFromStreamListener();</span>
                };
<span class="nc bnc" id="L8118" title="All 3 branches missed.">                case PLY_DOUBLE -&gt; switch (storageMode) {</span>
<span class="nc" id="L8119">                    case PLY_ASCII -&gt; new AsciiDoubleReadValueFromStreamListener();</span>
<span class="nc" id="L8120">                    case PLY_LITTLE_ENDIAN -&gt; new BinaryLittleEndianDoubleReadValueFromStreamListener();</span>
<span class="nc" id="L8121">                    case PLY_BIG_ENDIAN -&gt; new BinaryBigEndianDoubleReadValueFromStreamListener();</span>
                };
            };
        }

        /**
         * Sets the listener to read length value from temporal buffer to
         * provided property.
         *
         * @param property A PLY header property.
         * @throws NotAvailableException Raised if a listener cannot be set
         *                               for given property because its data type is not supported.
         */
        private void setReadLengthValueFromBufferListener(final PropertyPLY property) throws NotAvailableException {
<span class="pc bpc" id="L8135" title="16 of 17 branches missed.">            switch (property.getLengthType()) {</span>
                case PLY_INT8:
<span class="nc" id="L8137">                    property.setReadLengthValueFromBufferListener(new FaceInt8ReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8138">                    break;</span>
                case PLY_UINT8:
<span class="nc" id="L8140">                    property.setReadLengthValueFromBufferListener(new FaceUint8ReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8141">                    break;</span>
                case PLY_INT16:
<span class="nc" id="L8143">                    property.setReadLengthValueFromBufferListener(new FaceInt16ReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8144">                    break;</span>
                case PLY_UINT16:
<span class="nc" id="L8146">                    property.setReadLengthValueFromBufferListener(new FaceUint16ReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8147">                    break;</span>
                case PLY_INT32:
<span class="nc" id="L8149">                    property.setReadLengthValueFromBufferListener(new FaceInt32ReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8150">                    break;</span>
                case PLY_UINT32:
<span class="nc" id="L8152">                    property.setReadLengthValueFromBufferListener(new FaceUint32ReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8153">                    break;</span>
                case PLY_FLOAT32:
<span class="nc" id="L8155">                    property.setReadLengthValueFromBufferListener(new FaceFloat32ReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8156">                    break;</span>
                case PLY_FLOAT64:
<span class="nc" id="L8158">                    property.setReadLengthValueFromBufferListener(new FaceFloat64ReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8159">                    break;</span>
                case PLY_CHAR:
<span class="nc" id="L8161">                    property.setReadLengthValueFromBufferListener(new FaceCharReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8162">                    break;</span>
                case PLY_UCHAR:
<span class="fc" id="L8164">                    property.setReadLengthValueFromBufferListener(new FaceUcharReadLengthValueFromBufferListener());</span>
<span class="fc" id="L8165">                    break;</span>
                case PLY_SHORT:
<span class="nc" id="L8167">                    property.setReadLengthValueFromBufferListener(new FaceShortReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8168">                    break;</span>
                case PLY_USHORT:
<span class="nc" id="L8170">                    property.setReadLengthValueFromBufferListener(new FaceUshortReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8171">                    break;</span>
                case PLY_INT:
<span class="nc" id="L8173">                    property.setReadLengthValueFromBufferListener(new FaceIntReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8174">                    break;</span>
                case PLY_UINT:
<span class="nc" id="L8176">                    property.setReadLengthValueFromBufferListener(new FaceUintReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8177">                    break;</span>
                case PLY_FLOAT:
<span class="nc" id="L8179">                    property.setReadLengthValueFromBufferListener(new FaceFloatReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8180">                    break;</span>
                case PLY_DOUBLE:
<span class="nc" id="L8182">                    property.setReadLengthValueFromBufferListener(new FaceDoubleReadLengthValueFromBufferListener());</span>
<span class="nc" id="L8183">                    break;</span>
                default:
<span class="nc" id="L8185">                    throw new NotAvailableException();</span>
            }
<span class="fc" id="L8187">        }</span>
    }
}

//TODO: add cancel method
//TODO: add unit tests for loader ply
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>