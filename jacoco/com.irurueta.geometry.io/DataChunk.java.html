<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataChunk.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-geometry-io</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.geometry.io</a> &gt; <span class="el_source">DataChunk.java</span></div><h1>DataChunk.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.geometry.io;

/**
 * Class containing a piece of 3D data loaded from a file.
 * This class is used along with a LoaderIterator so that very large 3D files
 * can be read in a step-by-step process returning consecutive DataChunk's of
 * the file.
 */
public class DataChunk {
    /**
     * Constant defining minimum number of color components, which is 1 for
     * grayscale.
     */
    public static final int MIN_COLOR_COMPONENTS = 1;

    /**
     * Constant defining default number of color components for RGB
     */
    public static final int DEFAULT_COLOR_COMPONENTS = 3;

    /**
     * Array containing 3D coordinates for all points in a chunk in consecutive
     * order, that is, array will contain values x0, y0, z0, x1, y1, z1, ...
     * and so on.
     */
    private float[] coords;

    /**
     * Array containing the color for each vertex in the chunk of data.
     * Values will be stored consecutively as r0, g0, b0, r1, g1, b1, ...
     * and so on. If transparency is provided, then array will be stored as
     * r0, g0, b0, a0, r1, g1, b1, a1...
     *
     * @see #colorComponents
     */
    private short[] colors;

    /**
     * Array containing indices of vertices to build the triangles forming
     * the 3D shape on this chunk. Indices will be stored consecutively in sets
     * of 3, indicating the 3 vertices of each triangle, that is: p1a, p2a, p3a,
     * p1b, p2b, p3b, etc...
     * The indices will be used to pick appropriate point coordinates, texture
     * coordinates, normals or colors from their corresponding arrays.
     */
    private int[] indices;

    /**
     * Array containing texture coordinates in a texture image for a given 3D
     * point. All texture coordinates are stored consecutively in the array as:
     * x0, y0, x1, y1, etc.
     * Usually coordinates are stored in a normalized form having values between
     * 0.0 and 1.0. Usually larger values indicate that the image will repeat
     * when exceeding its borders, and negative values indicate that the image
     * will be reversed.
     */
    private float[] textureCoords;

    /**
     * Array containing normal coordinates for each vertex. Normal coordinates
     * are useful to draw correct lighting. All normal coordinates are stored
     * consecutively in the array as: x0, y0, z0, x1, y1, z1, etc.
     */
    private float[] normals;

    /**
     * Indicates number of color components stored in the array.
     * Usually for RGB it will be 3. When transparency is available, it will be
     * 4.
     */
    private int colorComponents;

    /**
     * X minimum coordinate of the bounding box containing all the data of this
     * data chunk.
     */
    private float minX;

    /**
     * Y minimum coordinate of the bounding box containing all the data of this
     * data chunk.
     */
    private float minY;

    /**
     * Z minimum coordinate of the bounding box containing all the data of this
     * data chunk.
     */
    private float minZ;

    /**
     * X maximum coordinate of the bounding box containing all the data of this
     * data chunk.
     */
    private float maxX;

    /**
     * Y maximum coordinate of the bounding box containing all the data of this
     * data chunk.
     */
    private float maxY;

    /**
     * Z maximum coordinate of the bounding box containing all the data of this
     * data chunk.
     */
    private float maxZ;

    /**
     * Material of this chunk. This will be used to define ambient colors,
     * textures etc. for this chunk.
     */
    private Material material;

    /**
     * Default Constructor
     */
<span class="fc" id="L133">    public DataChunk() {</span>
<span class="fc" id="L134">        coords = null;</span>
<span class="fc" id="L135">        colors = null;</span>
<span class="fc" id="L136">        indices = null;</span>
<span class="fc" id="L137">        textureCoords = null;</span>
<span class="fc" id="L138">        normals = null;</span>

<span class="fc" id="L140">        colorComponents = DEFAULT_COLOR_COMPONENTS;</span>

<span class="fc" id="L142">        minX = minY = minZ = Float.MAX_VALUE;</span>
<span class="fc" id="L143">        maxX = maxY = maxZ = -Float.MAX_VALUE;</span>
<span class="fc" id="L144">    }</span>

    /**
     * Sets array containing 3D coordinates for all points in a chunk in
     * consecutive order, that is, array will contain values x0, y0, z0, x1, y1,
     * z1, ... and so on.
     *
     * @param coords Array containing 3D coordinates for all points in a chunk.
     */
    public void setVerticesCoordinatesData(final float[] coords) {
<span class="fc" id="L154">        this.coords = coords;</span>
<span class="fc" id="L155">    }</span>

    /**
     * Returns array containing 3D coordinates for all points in a chunk in
     * consecutive order, that is, array will contain values x0, y0, z0, x1, y1,
     * z1... and so on.
     *
     * @return Array containing 3D coordinates for all points in a chunk.
     */
    public float[] getVerticesCoordinatesData() {
<span class="fc" id="L165">        return coords;</span>
    }

    /**
     * Indicates if array containing 3D coordinates has been provided and is
     * available for retrieval.
     *
     * @return True if available, false otherwise.
     */
    public boolean isVerticesCoordinatesDataAvailable() {
<span class="fc bfc" id="L175" title="All 2 branches covered.">        return coords != null;</span>
    }

    /**
     * Sets array containing the color for each vertex in the chunk of data.
     * Values will be stored consecutively as r0, g0, b0, r1, g1, b1, ...
     * and so on. If transparency is provided, then array will be stored as
     * r0, g0, b0, a0, r1, g1, b1, a1...
     *
     * @param colors Array containing the color for each vertex to be set
     * @see #getColorComponents()
     */
    public void setColorData(final short[] colors) {
<span class="fc" id="L188">        this.colors = colors;</span>
<span class="fc" id="L189">    }</span>

    /**
     * Returns array containing the color for each vertex in the chunk of data.
     * Array usually contains data stored consecutively as
     * r0, g0, b0, r1, g1, b1... and so on. If transparency is used, then array
     * will be stored as r0, g0, b0, a0, r1, g1, b1, a1...
     * There will be as many values per vertex as the number of color components
     *
     * @return array containing the color for each vertex in the chunk of data.
     */
    public short[] getColorData() {
<span class="fc" id="L201">        return colors;</span>
    }

    /**
     * Indicates if array containing the color for each vertex has been provided
     * and is available for retrieval.
     *
     * @return True if available, false otherwise.
     */
    public boolean isColorDataAvailable() {
<span class="fc bfc" id="L211" title="All 2 branches covered.">        return colors != null;</span>
    }

    /**
     * Sets array that contains indices of vertices to build the triangles
     * forming the 3D shape on this chunk. Indices need to be stored
     * consecutively in sets of 3, indicating the 3 vertices of each triangle,
     * that is: p1a, p2a, p3a, p1b, p2b, p3b, etc.
     * Provided indices will be used to pick appropriate point coordinates,
     * texture coordinates, normals or colors from their corresponding arrays
     *
     * @param indices indices of vertices to build triangles.
     */
    public void setIndicesData(final int[] indices) {
<span class="fc" id="L225">        this.indices = indices;</span>
<span class="fc" id="L226">    }</span>

    /**
     * Returns array containing indices of vertices to build the triangles
     * forming the 3D shape on this chunk. Indices will be stored consecutively
     * in sets of 3, indicating the 3 vertices of each triangle, that is: p1a,
     * p2a, p3a, p1b, p2b, p3b, etc.
     * Provided indices will be used to pick appropriate point coordinates,
     * texture coordinates, normals or colors from their corresponding arrays.
     *
     * @return Array containing indices of vertices to build the triangles.
     */
    public int[] getIndicesData() {
<span class="fc" id="L239">        return indices;</span>
    }

    /**
     * Indicates if array containing the indices of vertices to build the
     * triangles has been provided and is available for retrieval.
     *
     * @return True if available, false otherwise.
     */
    public boolean isIndicesDataAvailable() {
<span class="fc bfc" id="L249" title="All 2 branches covered.">        return indices != null;</span>
    }

    /**
     * Sets array containing texture coordinates in a texture image for a given
     * 3D point. All texture coordinates are stored consecutively in the array
     * as: x0, y0, x1, y1, etc.
     * Usually coordinates are stored in a normalized form having values between
     * 0.0 and 1.0. Usually larger values indicate that the image will repeat
     * when exceeding its borders, and negative values indicate that the image
     * will be reversed.
     *
     * @param textureCoords Array containing texture coordinates in a texture
     *                      image.
     */
    public void setTextureCoordinatesData(final float[] textureCoords) {
<span class="fc" id="L265">        this.textureCoords = textureCoords;</span>
<span class="fc" id="L266">    }</span>

    /**
     * Returns array containing texture coordinates in a texture image for a
     * given 3D point. All texture coordinates are stored consecutively in the
     * array as: x0, y0, x1, y1, etc.
     * Usually coordinates are stored in a normalized form having values between
     * 0.0 and 1.0. Usually larger values indicate that the image will repeat
     * when exceeding its borders, and negative values indicate that the image
     * will be reversed.
     *
     * @return Array containing texture coordinates in a texture image.
     */
    public float[] getTextureCoordinatesData() {
<span class="fc" id="L280">        return textureCoords;</span>
    }

    /**
     * Indicates if array containing texture coordinates in a texture image has
     * been provided and is available for retrieval.
     *
     * @return True if available, false otherwise.
     */
    public boolean isTextureCoordinatesDataAvailable() {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        return textureCoords != null;</span>
    }

    /**
     * Sets array containing normal coordinates for each vertex. Normal
     * coordinates are useful to draw correct lighting. All normal coordinates
     * are stored consecutively in the array as: x0, y0, z0, x1, y1, z1, etc.
     *
     * @param normals Array containing normal coordinates for each vertex.
     */
    public void setNormalsData(final float[] normals) {
<span class="fc" id="L301">        this.normals = normals;</span>
<span class="fc" id="L302">    }</span>

    /**
     * Returns array containing normal coordinates for each vertex. Normal
     * coordinates are useful to draw correct lighting. All normal coordinates
     * are stored consecutively in the array as: x0, y0, z0, x1, y1, z1, etc.
     *
     * @return Array containing normal coordinates for each vertex.
     */
    public float[] getNormalsData() {
<span class="fc" id="L312">        return normals;</span>
    }

    /**
     * Indicates if array containing normal coordinates for each vertex has
     * been provided and is available for retrieval.
     *
     * @return True if available, false otherwise.
     */
    public boolean isNormalsDataAvailable() {
<span class="fc bfc" id="L322" title="All 2 branches covered.">        return normals != null;</span>
    }

    /**
     * Returns number of color components stored in the array.
     * Usually for RGB it will be 3. When transparency is available, it will be
     * 4. For gray-scale it will be 1.
     *
     * @return Number of color components.
     */
    public int getColorComponents() {
<span class="fc" id="L333">        return colorComponents;</span>
    }

    /**
     * Sets number of color components stored in the array.
     * Usually for RGB it will be 3. When transparency is available, it will be
     * 4. For gray-scale it will be 1.
     *
     * @param colorComponents Number of color components stored in the array.
     * @throws IllegalArgumentException Raised if provided color components is
     *                                  negative.
     */
    public void setColorComponents(final int colorComponents) {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (colorComponents &lt; MIN_COLOR_COMPONENTS) {</span>
<span class="fc" id="L347">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L350">        this.colorComponents = colorComponents;</span>
<span class="fc" id="L351">    }</span>

    /**
     * Returns X minimum coordinate of the bounding box containing all the data
     * of this data chunk.
     *
     * @return X minimum coordinate of the bounding box.
     */
    public float getMinX() {
<span class="fc" id="L360">        return minX;</span>
    }

    /**
     * Sets X minimum coordinate of the bounding box containing all the data of
     * this data chunk.
     *
     * @param minX X minimum coordinate of the bounding box.
     */
    public void setMinX(final float minX) {
<span class="fc" id="L370">        this.minX = minX;</span>
<span class="fc" id="L371">    }</span>

    /**
     * Returns Y minimum coordinate of the bounding box containing all the data
     * of this data chunk.
     *
     * @return Y minimum coordinate of the bounding box.
     */
    public float getMinY() {
<span class="fc" id="L380">        return minY;</span>
    }

    /**
     * Sets Y minimum coordinate of the bounding box containing all the data of
     * this data chunk.
     *
     * @param minY Y minimum coordinate of the bounding box.
     */
    public void setMinY(final float minY) {
<span class="fc" id="L390">        this.minY = minY;</span>
<span class="fc" id="L391">    }</span>

    /**
     * Returns Z minimum coordinate of the bounding box containing all the data
     * of this data chunk.
     *
     * @return Z minimum coordinate of the bounding box.
     */
    public float getMinZ() {
<span class="fc" id="L400">        return minZ;</span>
    }

    /**
     * Sets Z minimum coordinate of the bounding box containing all the data of
     * this data chunk.
     *
     * @param minZ Z minimum coordinate of the bounding box.
     */
    public void setMinZ(final float minZ) {
<span class="fc" id="L410">        this.minZ = minZ;</span>
<span class="fc" id="L411">    }</span>

    /**
     * Returns X maximum coordinate of the bounding box containing all the data
     * of this data chunk.
     *
     * @return X maximum coordinate of the bounding box.
     */
    public float getMaxX() {
<span class="fc" id="L420">        return maxX;</span>
    }

    /**
     * Sets X maximum coordinate of the bounding box containing all the data of
     * this data chunk.
     *
     * @param maxX X maximum coordinate of the bounding box.
     */
    public void setMaxX(final float maxX) {
<span class="fc" id="L430">        this.maxX = maxX;</span>
<span class="fc" id="L431">    }</span>

    /**
     * Returns Y maximum coordinate of the bounding box containing all the data
     * of this data chunk.
     *
     * @return Y maximum coordinate of the bounding box.
     */
    public float getMaxY() {
<span class="fc" id="L440">        return maxY;</span>
    }

    /**
     * Sets Y maximum coordinate of the bounding box containing all the data
     * of this data chunk.
     *
     * @param maxY Y maximum coordinate of the bounding box.
     */
    public void setMaxY(final float maxY) {
<span class="fc" id="L450">        this.maxY = maxY;</span>
<span class="fc" id="L451">    }</span>

    /**
     * Returns Z maximum coordinate of the bounding box containing all the data
     * of this data chunk.
     *
     * @return Z maximum coordinate of the bounding box.
     */
    public float getMaxZ() {
<span class="fc" id="L460">        return maxZ;</span>
    }

    /**
     * Sets Z maximum coordinate of the bounding box containing all the data
     * of this data chunk.
     *
     * @param maxZ Z maximum coordinate of the bounding box.
     */
    public void setMaxZ(final float maxZ) {
<span class="fc" id="L470">        this.maxZ = maxZ;</span>
<span class="fc" id="L471">    }</span>

    /**
     * Returns material of this chunk. This will be used to define ambient
     * colors, textures, etc. for this chunk.
     *
     * @return Materials of this chunk.
     */
    public Material getMaterial() {
<span class="fc" id="L480">        return material;</span>
    }

    /**
     * Sets material of this chunk. This will be used to define ambient colors,
     * textures, etc. for this chunk.
     *
     * @param material Material of this chunk.
     */
    public void setMaterial(final Material material) {
<span class="fc" id="L490">        this.material = material;</span>
<span class="fc" id="L491">    }</span>

    /**
     * Returns boolean indicating whether a material has been provided for this
     * chunk.
     *
     * @return True if material is available, false otherwise.
     */
    public boolean isMaterialAvailable() {
<span class="fc bfc" id="L500" title="All 2 branches covered.">        return material != null;</span>
    }

    //TODO: create class to compute DataChunk statistics: bounding box, vertex
    // average, color limits, standard deviation and average, normal limits,
    // standard deviation and average, etc.
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>