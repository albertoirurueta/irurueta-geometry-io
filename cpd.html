<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from org.apache.maven.plugins:maven-pmd-plugin:3.21.2:cpd at 2024-12-07

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>com.irurueta:irurueta-geometry-io &#x2013; CPD Results</title>
    <link rel="stylesheet" href="./css/maven-base.css" />
    <link rel="stylesheet" href="./css/maven-theme.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">com.irurueta:irurueta-geometry-io
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2024-12-07</span>
           | <span id="projectVersion">Version: 1.4.0-SNAPSHOT</span>
      </div>
      <div class="xright"><a href="./" title="com.irurueta:irurueta-geometry-io">com.irurueta:irurueta-geometry-io</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
     <li class="expanded"><a href="project-reports.html" title="Project Reports">Project Reports</a>
      <ul>
       <li class="none"><a href="apidocs/index.html" title="Javadoc">Javadoc</a></li>
       <li class="none"><a href="testapidocs/index.html" title="Test Javadoc">Test Javadoc</a></li>
       <li class="none"><a href="surefire-report.html" title="Surefire">Surefire</a></li>
       <li class="none"><a href="checkstyle.html" title="Checkstyle">Checkstyle</a></li>
       <li class="none"><a href="spotbugs.html" title="SpotBugs">SpotBugs</a></li>
       <li class="none"><strong>CPD</strong></li>
       <li class="none"><a href="pmd.html" title="PMD">PMD</a></li>
       <li class="none"><a href="xref/index.html" title="Source Xref">Source Xref</a></li>
       <li class="none"><a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a></li>
      </ul></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<section>
<h2><a name="CPD_Results"></a>CPD Results</h2><a name="CPD_Results"></a>
<p>The following document contains the results of PMD's  <a class="externalLink" href="https://pmd.github.io/latest/pmd_userdocs_cpd.html">CPD</a> 6.55.0.</p><section>
<h3><a name="Duplications"></a>Duplications</h3><a name="Duplications"></a>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/Loader.java</td>
<td><a href="./xref/com/irurueta/geometry/io/Loader.html#L121">121</a></td></tr>
<tr class="a">
<td align="left">com/irurueta/geometry/io/MaterialLoader.java</td>
<td><a href="./xref/com/irurueta/geometry/io/MaterialLoader.html#L140">140</a></td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>}

    /**
     * Get maximum size (in bytes) to determine whether a file is completely
     * cached in memory (if lower than maximum size), or if it is just streamed
     * (if greater than maximum size).
     *
     * @return Maximum size to determine whether file is cached in memory or not.
     */
    public long getFileSizeLimitToKeepInMemory() {
        return fileSizeLimitToKeepInMemory;
    }

    /**
     * Sets maximum size (in bytes) to determine whether a file is completely
     * cached in memory (if lower than maximum size), or if it is just streamed
     * (if greater than maximum size).
     *
     * @param fileSizeLimitToKeepInMemory maximum size to determine whether file
     *                                    is cached in memory or not.
     * @throws LockedException if loader is locked because it is currently
     *                         processing a file.
     */
    public void setFileSizeLimitToKeepInMemory(final long fileSizeLimitToKeepInMemory) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.fileSizeLimitToKeepInMemory = fileSizeLimitToKeepInMemory;
    }

    /**
     * Indicates whether a file to be loaded has already been set.
     *
     * @return True if file has already been provided, false otherwise.
     */
    public boolean hasFile() {
        return reader != null;
    }

    /**
     * Sets file to be loaded.
     *
     * @param f file to be loaded.
     * @throws LockedException raised if this instance is loaded because a file
     *                         is already being loaded.
     * @throws IOException     raised if provided file does not exist or if an I/O
     *                         exception occurs.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    public void setFile(final File f) throws LockedException, IOException {
        if (isLocked()) {
            throw new LockedException();
        }
        file = f;

        if (reader != null) {
            // close previous file
            reader.close();
        }

        if (f.length() &lt; fileSizeLimitToKeepInMemory) {
            reader = new MappedFileReaderAndWriter(f, FileChannel.MapMode.READ_ONLY);
        } else {
            reader = new FileReaderAndWriter(f, FileChannel.MapMode.READ_ONLY);
        }
    }

    /**
     * Closes file provided to this loader.
     *
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void close() throws IOException {
        if (reader != null) {
            reader.close();
            reader = null;
        }
    }

    /**
     * Determines whether this instance is locked.
     * A loader remains locked while decoding of a file is being done.
     * This instance will remain locked once the loading process starts until
     * it finishes either successfully or not.
     * While this instance remains locked no parameters can be changed,
     * otherwise a LockedException will be raised.
     *
     * @return True if instance is locked, false otherwise.
     */
    public synchronized boolean isLocked() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/FileReaderAndWriter.java</td>
<td><a href="./xref/com/irurueta/geometry/io/FileReaderAndWriter.html#L805">805</a></td></tr>
<tr class="a">
<td align="left">com/irurueta/geometry/io/MappedFileReaderAndWriter.java</td>
<td><a href="./xref/com/irurueta/geometry/io/MappedFileReaderAndWriter.html#L821">821</a></td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>}

    /**
     * Writes an unsigned int to the file as four bytes, using provided endian
     * type.
     * Provided integer value is converted to an unsigned int by taking into
     * account only the four lower bytes.
     * If endian type is big endian, then natural byte order is preserved (and
     * high byte is written first), if little endian order is chosen, then byte
     * order is reversed.
     * The write starts at the current position of the file pointer.
     *
     * @param v          an unsigned int to be written (long is converted to unsigned
     *                   short).
     * @param endianType endian type. If it is big endian, natural byte order is
     *                   preserved, otherwise byte order is reversed.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeUnsignedInt(final long v, final EndianType endianType) throws IOException {
        final var firstIntByte = (int) (0xff &amp; (v &gt;&gt; 24));
        final var secondIntByte = (int) (0xff &amp; ((v &lt;&lt; 8) &gt;&gt; 24));
        final var thirdIntByte = (int) (0xff &amp; ((v &lt;&lt; 16) &gt;&gt; 24));
        final var fourthIntByte = (int) (0xff &amp; ((v &lt;&lt; 24) &gt;&gt; 24));

        final var machineValue = (firstIntByte &lt;&lt; 24) | (secondIntByte &lt;&lt; 16) | (thirdIntByte &lt;&lt; 8) | fourthIntByte;
        final var value = Util.toEndianType(endianType, machineValue);

        randomAccessFile.writeInt(value);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/LoaderOBJ.java</td>
<td><a href="./xref/com/irurueta/geometry/io/LoaderOBJ.html#L1430">1430</a></td></tr>
<tr class="a">
<td align="left">com/irurueta/geometry/io/LoaderOBJ.java</td>
<td><a href="./xref/com/irurueta/geometry/io/LoaderOBJ.html#L1986">1986</a></td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>String vertexLine = reader.readLine();
                                    if (!vertexLine.startsWith(&quot;v &quot;)) {
                                        throw new LoaderException();
                                    }
                                    vertexLine = vertexLine.substring(&quot;v &quot;.length()).trim();
                                    // retrieve words in vertexLine, which contain
                                    // vertex coordinates either as x, y, z or x,
                                    // y, z, w
                                    final var vertexCoordinates = vertexLine.split(&quot; &quot;);
                                    if (vertexCoordinates.length == 4) {
                                        // homogeneous coordinates x, y, z, w

                                        // check that values are valid
                                        if (vertexCoordinates[0].isEmpty()) {
                                            throw new LoaderException();
                                        }
                                        if (vertexCoordinates[1].isEmpty()) {
                                            throw new LoaderException();
                                        }
                                        if (vertexCoordinates[2].isEmpty()) {
                                            throw new LoaderException();
                                        }
                                        if (vertexCoordinates[3].isEmpty()) {
                                            throw new LoaderException();
                                        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/LoaderOBJ.java</td>
<td><a href="./xref/com/irurueta/geometry/io/LoaderOBJ.html#L1688">1688</a></td></tr>
<tr class="a">
<td align="left">com/irurueta/geometry/io/LoaderOBJ.java</td>
<td><a href="./xref/com/irurueta/geometry/io/LoaderOBJ.html#L1762">1762</a></td></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/LoaderOBJ.java</td>
<td><a href="./xref/com/irurueta/geometry/io/LoaderOBJ.html#L1836">1836</a></td></tr>
<tr class="a">
<td colspan="2" align="left">
<div class="source">
<pre>final var entry = verticesStreamPositionMap.floorEntry(index);
                if (entry != null) {
                    final var origIndex = entry.getKey();
                    final var pos = entry.getValue();
                    if ((origIndex &lt;= index) &amp;&amp; (pos &gt;= 0)) {
                        startIndex = origIndex;
                        startStreamPos = pos;
                    }
                }
            }

            // if we need to read next vertex, don't do anything, otherwise
            // move to next vertex location if reading some vertex located
            // further on the stream. For previous vertex indices, start
            // from beginning
            if (reader.getPosition() != startStreamPos) {
                reader.seek(startStreamPos);
            }

            // read from stream until start of data of desired vertex
            var streamPosition = 0L;
            for (var i = startIndex; i &lt;= index; i++) {

                // when traversing stream of data until reaching desired
                // index, we add all vertex, texture and normal positions
                // into maps
                String str;
                var end = false;
                do {
                    streamPosition = reader.getPosition();
                    str = reader.readLine();
                    if (str == null) {
                        end = true;
                        break;
                    }

                    if (str.startsWith(&quot;v &quot;)) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/FileReaderAndWriter.java</td>
<td><a href="./xref/com/irurueta/geometry/io/FileReaderAndWriter.html#L783">783</a></td></tr>
<tr class="a">
<td align="left">com/irurueta/geometry/io/MappedFileReaderAndWriter.java</td>
<td><a href="./xref/com/irurueta/geometry/io/MappedFileReaderAndWriter.html#L798">798</a></td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>}

    /**
     * Writes an unsigned int to the file as four bytes, high byte first.
     * Provided integer value is converted to an unsigned int by taking into
     * account only the four lower bytes. The write starts at the current
     * position of the file pointer.
     *
     * @param v an unsigned int to be written (long is converted to unsigned
     *          int).
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void writeUnsignedInt(final long v) throws IOException {
        final var firstIntByte = (int) (0xff &amp; (v &gt;&gt; 24));
        final var secondIntByte = (int) (0xff &amp; ((v &lt;&lt; 8) &gt;&gt; 24));
        final var thirdIntByte = (int) (0xff &amp; ((v &lt;&lt; 16) &gt;&gt; 24));
        final var fourthIntByte = (int) (0xff &amp; ((v &lt;&lt; 24) &gt;&gt; 24));

        final var value = (firstIntByte &lt;&lt; 24) | (secondIntByte &lt;&lt; 16) | (thirdIntByte &lt;&lt; 8) | fourthIntByte;

        randomAccessFile.writeInt(value);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/MeshWriterBinary.java</td>
<td><a href="./xref/com/irurueta/geometry/io/MeshWriterBinary.html#L129">129</a></td></tr>
<tr class="a">
<td align="left">com/irurueta/geometry/io/MeshWriterJson.java</td>
<td><a href="./xref/com/irurueta/geometry/io/MeshWriterJson.html#L293">293</a></td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>if (chunk.getMinX() &lt; minX) {
                    minX = chunk.getMinX();
                }
                if (chunk.getMinY() &lt; minY) {
                    minY = chunk.getMinY();
                }
                if (chunk.getMinZ() &lt; minZ) {
                    minZ = chunk.getMinZ();
                }

                if (chunk.getMaxX() &gt; maxX) {
                    maxX = chunk.getMaxX();
                }
                if (chunk.getMaxY() &gt; maxY) {
                    maxY = chunk.getMaxY();
                }
                if (chunk.getMaxZ() &gt; maxZ) {
                    maxZ = chunk.getMaxZ();
                }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/LoaderOBJ.java</td>
<td><a href="./xref/com/irurueta/geometry/io/LoaderOBJ.html#L647">647</a></td></tr>
<tr class="a">
<td align="left">com/irurueta/geometry/io/LoaderSTL.java</td>
<td><a href="./xref/com/irurueta/geometry/io/LoaderSTL.html#L202">202</a></td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>}

    /**
     * Determines if provided file is a valid file that can be read by this
     * loader.
     *
     * @return true if file is valid, false otherwise.
     * @throws LockedException raised if this instance is already locked.
     * @throws IOException     if an I/O error occurs..
     */
    @Override
    public boolean isValidFile() throws LockedException, IOException {
        if (!hasFile()) {
            throw new IOException();
        }
        if (isLocked()) {
            throw new LockedException();
        }
        return true;
    }

    /**
     * Starts the loading process of provided file.
     * This method returns a LoaderIterator to start the iterative process to
     * load a file in small chunks of data.
     *
     * @return a loader iterator to read the file in a step-by-step process.
     * @throws LockedException   raised if this instance is already locked.
     * @throws NotReadyException raised if this instance is not yet ready.
     * @throws IOException       if an I/O error occurs.
     * @throws LoaderException   if file is corrupted or cannot be interpreted.
     */
    @Override
    public LoaderIterator load() throws LockedException, NotReadyException, IOException, LoaderException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        setLocked(true);
        if (listener != null) {
            listener.onLoadStart(this);
        }

        loaderIterator = new LoaderIteratorOBJ(this);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td align="left">com/irurueta/geometry/io/FileReaderAndWriter.java</td>
<td><a href="./xref/com/irurueta/geometry/io/FileReaderAndWriter.html#L442">442</a></td></tr>
<tr class="a">
<td align="left">com/irurueta/geometry/io/MappedFileReaderAndWriter.java</td>
<td><a href="./xref/com/irurueta/geometry/io/MappedFileReaderAndWriter.html#L463">463</a></td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>final var streamValue = randomAccessFile.readInt();
        final var value = Util.fromEndianType(endianType, streamValue);

        // convert value to byte array
        final var firstIntByte = 0xff &amp; (value &gt;&gt; 24);
        final var secondIntByte = 0xff &amp; ((value &lt;&lt; 8) &gt;&gt; 24);
        final var thirdIntByte = 0xff &amp; ((value &lt;&lt; 16) &gt;&gt; 24);
        final var fourthIntByte = 0xff &amp; ((value &lt;&lt; 24) &gt;&gt; 24);

        // return it as integer
        return ((long) firstIntByte &lt;&lt; 24) | (secondIntByte &lt;&lt; 16) | (thirdIntByte &lt;&lt; 8) | fourthIntByte;
    }

    /**
     * Reads a signed 64-bit integer from this file. This method reads eight
     * bytes from the file, starting at the current file pointer. If the bytes
     * read, in order, are b1, b2, b3, b4, b5, b6, b7, and b8, where:
     * 0 &amp;lt;= b1, b2, b3, b4. b5. b6. b7. b8 &amp;lt;= 255,
     * then the result is equal to:
     * ((long)b1 &amp;lt;&amp;lt; 56) + ((long)b2 &amp;lt;&amp;lt; 48)
     * + ((long)b3 &amp;lt;&amp;lt; 40) + ((long)b4 &amp;lt;&amp;lt; 32)
     * + ((long)b5 &amp;lt;&amp;lt; 24) + ((long)b6 &amp;lt;&amp;lt; 16)
     * + ((long)b7 &amp;lt;&amp;lt; 8) + b8
     * This method blocks until the eight bytes are read, the end of the stream
     * is detected, or an exception is thrown.
     *
     * @return the next eight bytes of this file, interpreted as a long.
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public long readLong() throws IOException {</pre></div></td></tr></table></section></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2017&#x2013;2024..      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
